(() => {
const Ur = `.consent-container *,.consent-container :before,.consent-container :after{box-sizing:border-box;border-width:0;border-style:solid;border-color:currentColor}.consent-container hr{height:0;color:inherit;border-top-width:1px}.consent-container abbr:where([title]){-webkit-text-decoration:underline dotted;text-decoration:underline dotted}.consent-container h1,.consent-container h2,.consent-container h3,.consent-container h4,.consent-container h5,.consent-container h6{font-size:inherit;font-weight:inherit}.consent-container a{color:inherit;text-decoration:inherit}.consent-container b,.consent-container strong{font-weight:bolder}.consent-container code,.consent-container kbd,.consent-container samp,.consent-container pre{font-family:ui-monospace,SFMono-Regular,Menlo,Monaco,Consolas,Liberation Mono,Courier New,monospace;font-size:1em}.consent-container small{font-size:80%}.consent-container sub,.consent-container sup{font-size:75%;line-height:0;position:relative;vertical-align:baseline}.consent-container sub{bottom:-.25em}.consent-container sup{top:-.5em}.consent-container table{text-indent:0;border-color:inherit;border-collapse:collapse}.consent-container button,.consent-container input,.consent-container optgroup,.consent-container select,.consent-container textarea{font-family:inherit;font-feature-settings:inherit;font-variation-settings:inherit;font-size:100%;font-weight:inherit;line-height:inherit;color:inherit;margin:0;padding:0}.consent-container button,.consent-container select{text-transform:none}.consent-container button,.consent-container [type=button],.consent-container [type=reset],.consent-container [type=submit]{background-color:transparent;background-image:none}.consent-container :-moz-focusring{outline:auto}.consent-container :-moz-ui-invalid{box-shadow:none}.consent-container progress{vertical-align:baseline}.consent-container ::-webkit-inner-spin-button,.consent-container ::-webkit-outer-spin-button{height:auto}.consent-container [type=search]{outline-offset:-2px}.consent-container ::-webkit-search-decoration{-webkit-appearance:none}.consent-container ::-webkit-file-upload-button{-webkit-appearance:button;font:inherit}.consent-container summary{display:list-item}.consent-container blockquote,.consent-container dl,.consent-container dd,.consent-container h1,.consent-container h2,.consent-container h3,.consent-container h4,.consent-container h5,.consent-container h6,.consent-container hr,.consent-container figure,.consent-container p,.consent-container pre{margin:0}.consent-container fieldset{margin:0;padding:0}.consent-container legend{padding:0}.consent-container ol,.consent-container ul,.consent-container menu{list-style:none;margin:0;padding:0}.consent-container dialog{padding:0}.consent-container textarea{resize:vertical}.consent-container input::-moz-placeholder,.consent-container textarea::-moz-placeholder{opacity:1;color:#9ca3af}.consent-container input::placeholder,.consent-container textarea::placeholder{opacity:1;color:#9ca3af}.consent-container button,.consent-container [role=button]{cursor:pointer}.consent-container :disabled{cursor:default}.consent-container img,.consent-container svg,.consent-container video,.consent-container canvas,.consent-container audio,.consent-container iframe,.consent-container embed,.consent-container object{display:block}.consent-container img,.consent-container video{max-width:100%;height:auto}.consent-container [hidden]{display:none}#udem_cookie_consent_toggle a{cursor:pointer}.consent-container:not(.overlay-modal) .modal-backdrop{position:relative;height:auto}.consent-container.overlay-modal .modal-backdrop{background-color:#00000080;height:10000px}.consent-container{--consent-modal-font-size: 14px;--consent-modal-line-height: 17.5px;--consent-modal-title-font-size: 18px;--consent-modal-title-line-height: 20px;--toggle-width: 40px;--toggle-height: 17.5px;--toggle-border: 1px;--toggle-font-size: 7.5px;--toggle-duration: .15s;--toggle-bg-on: #10b981;--toggle-bg-off: #9397B0;--toggle-bg-on-disabled: #d1d5db;--toggle-bg-off-disabled: #e5e7eb;--toggle-border-on: #10b981;--toggle-border-off: #e5e7eb;--toggle-border-on-disabled: #d1d5db;--toggle-border-off-disabled: #e5e7eb;--toggle-ring-width: 3px;--toggle-ring-color: #10B98130;--toggle-text-on: #ffffff;--toggle-text-off: #374151;--toggle-text-on-disabled: #9ca3af;--toggle-text-off-disabled: #9ca3af;--toggle-handle-enabled: #ffffff;--toggle-handle-disabled: #f3f4f6}.consent-container .modal-backdrop{background-color:transparent;bottom:0;left:0;overflow-y:auto;position:absolute;right:0;top:0;width:100%;z-index:200}.consent-container .modal-backdrop>div{display:flex;justify-content:center}.consent-container .modal-container{border-top:10px solid #0b113a;bottom:0;color:#0b113a;background:#e5f0f8;height:450px;margin-top:-220px;max-height:80%;text-align:left;overflow:hidden;position:fixed;width:100%}@media screen and (min-width: 640px){.consent-container .modal-container{height:auto}}.consent-container .modal-container a{text-decoration:underline;text-underline-offset:2px}.consent-container .step-two-container{height:80%}@media screen and (min-width: 640px){.consent-container .step-two-container{height:450px}}.consent-container .btn-close-modal{display:none}.consent-container .step-two-container .btn-close-modal{display:block;position:absolute;right:10px;top:15px;z-index:10}.consent-container .show-modal,.consent-container .show-modal-step-two{font-size:var(--consent-modal-font-size);height:100%;line-height:var(--consent-modal-line-height);margin:0 auto;max-width:1200px;padding:60px 35px 25px;z-index:0}.consent-container .show-modal p,.consent-container .show-modal-step-two p{font-size:var(--consent-modal-font-size);line-height:var(--consent-modal-line-height)}.consent-container .show-modal>span,.consent-container .show-modal-step-two>span{display:block;font-size:var(--consent-modal-title-font-size);line-height:var(--consent-modal-title-line-height);padding-bottom:12.5px}.consent-container .show-modal div.learn-more-container,.consent-container .show-modal-step-two div.learn-more-container{font-size:var(--consent-modal-font-size);line-height:var(--consent-modal-line-height)}@media screen and (min-width: 640px){.consent-container .show-modal div.learn-more-container,.consent-container .show-modal-step-two div.learn-more-container{padding-bottom:5px}}.consent-container .show-modal div.learn-more-container,.consent-container .show-modal-step-two div.learn-more-container{margin:20px 0 0}@media screen and (min-width: 640px){.consent-container .show-modal div.learn-more-container,.consent-container .show-modal-step-two div.learn-more-container{margin:14px 0 0}}@media screen and (min-width: 640px){.consent-container .show-modal,.consent-container .show-modal-step-two{height:450px}}@media screen and (min-width: 375px){.consent-container .show-modal{padding:50px 35px 25px}}@media screen and (min-width: 640px){.consent-container .show-modal{height:auto;padding:50px 50px 20px}}.consent-container .show-modal p{font-size:var(--consent-modal-font-size);line-height:var(--consent-modal-line-height);padding-bottom:20px}@media screen and (min-width: 640px){.consent-container .show-modal p{padding-bottom:5px}}.consent-container .show-modal-step-two .personalized-cookies-description p{padding:0 15px 20px 0}.consent-container .show-modal-step-two .btn-consent{width:100%}@media screen and (min-width: 640px){.consent-container .show-modal-step-two .btn-consent{width:auto}}.consent-container .show-modal-step-two .btn-modal-container{margin-top:20px}.consent-container .btn-modal-container{justify-content:center;margin:0 auto}@media screen and (min-width: 640px){.consent-container .btn-modal-container{display:flex;justify-content:normal;margin:0}}.consent-container .btn-consent{background-color:#0b113a;color:#fff;display:flex;font-weight:500;font-size:var(--consent-modal-font-size);line-height:var(--consent-modal-line-height);justify-content:center;margin:7.5px auto 0;padding:5px 15px;width:200px}@media screen and (min-width: 640px){.consent-container .btn-consent{float:left;margin:7.5px 0 0 7.5px;width:auto}}.consent-container .btn-consent span{color:#0057ac;padding-left:6.25px}.consent-container .btn-consent.open-modal-parameter{background-color:transparent;border:1px solid #0057ac;color:#0b113a}@media screen and (min-width: 640px){.consent-container .btn-consent.open-modal-parameter{margin-left:0}}@media screen and (min-width: 640px){.consent-container .confirm-selection{margin-left:0}}.consent-container .update-information{margin-top:20px}.consent-container .accordion-container{margin:0 auto;width:100%}.consent-container .accordion-container .close{color:#0057ac;font-size:22.5px;font-weight:400;line-height:27px;opacity:1;padding-right:8.75px}.consent-container .accordion-container .open{color:#0057ac;font-size:39px;font-weight:300;line-height:20px;opacity:1;padding-right:8.75px}.consent-container .accordion-container .list-title{padding-top:10px}.consent-container .accordion-container ul li{font-size:var(--consent-modal-font-size);list-style-type:disc;margin:10px 0 0 15px}.consent-container .accordion-container ul li::marker{color:#0057ac}.consent-container .accordion-list{width:100%}.consent-container .accordion-list .accordion-item{margin:0 0 -1px;--content-height: 0px;height:calc(var(--summary-height) + 26px);overflow:hidden;transition:height .3s ease-in-out;border:1px solid #9e9e9e}.consent-container details>summary{list-style:none}.consent-container details>summary::-webkit-details-marker{display:none}.consent-container .accordion-list .accordion-item>.accordion-item__summary{padding:12px 60px 12px 12px;cursor:pointer;display:flex;font-weight:700;line-height:24px;transition:color .3s ease-in-out;position:relative}.consent-container .accordion-list .accordion-item>.accordion-item__summary .accordion-item__summary-title{order:2;padding-top:2px}.consent-container .accordion-list .accordion-item.accordion-item--open>.accordion-item__summary .accordion-item__summary-icon span.close,.consent-container .accordion-list .accordion-item>.accordion-item__summary .accordion-item__summary-icon span.open{display:none}.consent-container .accordion-list .accordion-item.accordion-item--open>.accordion-item__summary .accordion-item__summary-icon span.open{display:block}.consent-container .accordion-list .accordion-item>.accordion-item__summary>.accordion-item__summary-icon{transition:transform .3s ease-in-out}.consent-container .accordion-list .accordion-item>.accordion-item__summary>.accordion-item__summary-icon span{text-shadow:none}.consent-container .accordion-list .accordion-item--open{height:calc(var(--summary-height) + var(--content-height) + 51px)}.consent-container .accordion-list .accordion-item--disabled>.accordion-item__summary{cursor:default}.consent-container .accordion-list .accordion-item>.accordion-item__content{border-top:none;padding:0;margin:0 25px 0 35px}.consent-container .ps{overflow:hidden!important;overflow-anchor:none;-ms-overflow-style:none;touch-action:auto;-ms-touch-action:auto}.consent-container .ps__rail-x{display:none;opacity:0;transition:background-color .2s linear,opacity .2s linear;-webkit-transition:background-color .2s linear,opacity .2s linear;height:15px;bottom:0;position:absolute}.consent-container .ps__rail-y{transition:background-color .2s linear,opacity .2s linear;-webkit-transition:background-color .2s linear,opacity .2s linear;width:15px;right:0;position:absolute;margin-top:60px;top:0!important}.consent-container .ps--active-x>.ps__rail-x,.consent-container .ps--active-y>.ps__rail-y{display:block;background-color:transparent}.consent-container .ps__thumb-x{background-color:#aaa;border-radius:6px;transition:background-color .2s linear,height .2s ease-in-out;-webkit-transition:background-color .2s linear,height .2s ease-in-out;height:6px;bottom:2px;position:absolute}.consent-container .ps__thumb-y{background-color:#aaa;border-radius:6px;transition:background-color .2s linear,width .2s ease-in-out;-webkit-transition:background-color .2s linear,width .2s ease-in-out;width:11px;right:2px;position:absolute}.consent-container .ps__rail-x:hover>.ps__thumb-x,.consent-container .ps__rail-x:focus>.ps__thumb-x,.consent-container .ps__rail-x.ps--clicking .ps__thumb-x{background-color:#999;height:11px}.consent-container .ps__rail-y:hover>.ps__thumb-y,.consent-container .ps__rail-y:focus>.ps__thumb-y,.consent-container .ps__rail-y.ps--clicking .ps__thumb-y{background-color:#999;width:11px}@supports (-ms-overflow-style: none){.consent-container .ps{overflow:auto!important}}@media screen and (-ms-high-contrast: active),(-ms-high-contrast: none){.consent-container .ps{overflow:auto!important}}.consent-container .toggle-container{display:inline-block;position:absolute;right:15px;top:15px}.consent-container .toggle-container.label{color:#0b113a;font-size:var(--consent-modal-font-size);line-height:var(--consent-modal-line-height);right:10px;text-align:right;text-wrap:wrap;top:4px;white-space:normal;width:70px}@media screen and (min-width: 480px){.consent-container .toggle-container.label{right:15px;top:15px;width:auto}}.consent-container .toggle-container:focus{box-shadow:0 0 0 var(--toggle-ring-width, 3px) var(--toggle-ring-color, rgba(16, 185, 129, .188));outline:none}.consent-container .toggle{align-items:center;border:var(--toggle-border, .125rem) solid;border-radius:999px;box-sizing:content-box;cursor:pointer;display:flex;font-size:var(--toggle-font-size, .75rem);height:var(--toggle-height, 1.25rem);line-height:1;position:relative;transition:all .3s;width:var(--toggle-width, 3rem)}.consent-container .toggle-on{background:var(--toggle-bg-on, #52b782);border-color:var(--toggle-border-on, #52b782);color:var(--toggle-text-on, #fff);justify-content:flex-start}.consent-container .toggle-off{background:var(--toggle-bg-off, #e5e7eb);border-color:var(--toggle-border-off, #e5e7eb);color:var(--toggle-text-off, #374151);justify-content:flex-end}.consent-container .toggle-on-disabled{background:var(--toggle-bg-on-disabled, #d1d5db);border-color:var(--toggle-border-on-disabled, #d1d5db);color:var(--toggle-text-on-disabled, #9ca3af);cursor:not-allowed;justify-content:flex-start}.consent-container .toggle-off-disabled{background:var(--toggle-bg-off-disabled, #e5e7eb);border-color:var(--toggle-border-off-disabled, #e5e7eb);color:var(--toggle-text-off-disabled, #9ca3af);cursor:not-allowed;justify-content:flex-end}.consent-container .toggle-handle{background:var(--toggle-handle-enabled, #fff);border-radius:50%;display:inline-block;height:var(--toggle-height, 1.25rem);position:absolute;top:0;transition-duration:var(--toggle-duration, .15s);transition-property:all;transition-timing-function:cubic-bezier(.4,0,.2,1);width:var(--toggle-height, 1.25rem)}.consent-container .toggle-handle-on{left:100%;transform:translate(-100%)}.consent-container .toggle-handle-off{left:0}.consent-container .toggle-handle-on-disabled{background:var(--toggle-handle-disabled, #f3f4f6);left:100%;transform:translate(-100%)}.consent-container .toggle-handle-off-disabled{background:var(--toggle-handle-disabled, #f3f4f6);left:0}.consent-container .toggle-label{box-sizing:border-box;text-align:center;-webkit-user-select:none;-moz-user-select:none;user-select:none;white-space:nowrap;width:calc(var(--toggle-width, 3.25rem) - var(--toggle-height, 1.25rem))}
`, Jn = "udem-cookie-consent-", Hs = "udem-cookie-consent", $s = new EventTarget(), Vr = function(e, t) {
  $s.addEventListener(e, t);
}, Ds = function(e) {
  $s.dispatchEvent(
    new CustomEvent(
      Hs,
      { detail: e }
    )
  );
}, Ns = async function() {
  await Promise.resolve();
  const e = { performanceCookies: "", functionalityCookies: "", adsCookies: "" };
  for (const [t] of Object.entries(e)) {
    if (localStorage.getItem(Jn + t) === null)
      return null;
    e[t] = localStorage.getItem(Jn + t) === "true";
  }
  return e;
}, Jr = async function(e) {
  await Promise.resolve();
  const t = await Ns();
  let n = !1;
  for (const [o, s] of Object.entries(e)) {
    if (typeof s > "u") {
      console.log("WARNING save() was called with an undefined value!");
      return;
    }
    (t !== null && s !== t[o] || t === null) && (localStorage.setItem(Jn + o, s ? "true" : "false"), n = !0, e[o] = s);
  }
  e.update = n, Ds(e);
}, Ye = {
  addEventListener: Vr,
  dispatchEvent: Ds,
  EVENT_TYPE_CONSENT: Hs,
  load: Ns,
  save: Jr
};
function go(e, t) {
  const n = /* @__PURE__ */ Object.create(null), o = e.split(",");
  for (let s = 0; s < o.length; s++)
    n[o[s]] = !0;
  return t ? (s) => !!n[s.toLowerCase()] : (s) => !!n[s];
}
const J = {}, kt = [], Se = () => {
}, Zr = () => !1, Qr = /^on[^a-z]/, Tn = (e) => Qr.test(e), mo = (e) => e.startsWith("onUpdate:"), re = Object.assign, bo = (e, t) => {
  const n = e.indexOf(t);
  n > -1 && e.splice(n, 1);
}, Gr = Object.prototype.hasOwnProperty, X = (e, t) => Gr.call(e, t), $ = Array.isArray, Ct = (e) => En(e) === "[object Map]", Fs = (e) => En(e) === "[object Set]", W = (e) => typeof e == "function", ie = (e) => typeof e == "string", _o = (e) => typeof e == "symbol", Z = (e) => e !== null && typeof e == "object", Ws = (e) => Z(e) && W(e.then) && W(e.catch), Ys = Object.prototype.toString, En = (e) => Ys.call(e), ei = (e) => En(e).slice(8, -1), Bs = (e) => En(e) === "[object Object]", vo = (e) => ie(e) && e !== "NaN" && e[0] !== "-" && "" + parseInt(e, 10) === e, pn = /* @__PURE__ */ go(
  // the leading comma is intentional so empty string "" is also included
  ",key,ref,ref_for,ref_key,onVnodeBeforeMount,onVnodeMounted,onVnodeBeforeUpdate,onVnodeUpdated,onVnodeBeforeUnmount,onVnodeUnmounted"
), An = (e) => {
  const t = /* @__PURE__ */ Object.create(null);
  return (n) => t[n] || (t[n] = e(n));
}, ti = /-(\w)/g, Ne = An((e) => e.replace(ti, (t, n) => n ? n.toUpperCase() : "")), ni = /\B([A-Z])/g, bt = An(
  (e) => e.replace(ni, "-$1").toLowerCase()
), Mn = An(
  (e) => e.charAt(0).toUpperCase() + e.slice(1)
), Yn = An(
  (e) => e ? `on${Mn(e)}` : ""
), Kt = (e, t) => !Object.is(e, t), Bn = (e, t) => {
  for (let n = 0; n < e.length; n++)
    e[n](t);
}, mn = (e, t, n) => {
  Object.defineProperty(e, t, {
    configurable: !0,
    enumerable: !1,
    value: n
  });
}, oi = (e) => {
  const t = parseFloat(e);
  return isNaN(t) ? e : t;
}, si = (e) => {
  const t = ie(e) ? Number(e) : NaN;
  return isNaN(t) ? e : t;
};
let jo;
const Zn = () => jo || (jo = typeof globalThis < "u" ? globalThis : typeof self < "u" ? self : typeof window < "u" ? window : typeof global < "u" ? global : {});
function yo(e) {
  if ($(e)) {
    const t = {};
    for (let n = 0; n < e.length; n++) {
      const o = e[n], s = ie(o) ? ai(o) : yo(o);
      if (s)
        for (const r in s)
          t[r] = s[r];
    }
    return t;
  } else {
    if (ie(e))
      return e;
    if (Z(e))
      return e;
  }
}
const ri = /;(?![^(]*\))/g, ii = /:([^]+)/, li = /\/\*[^]*?\*\//g;
function ai(e) {
  const t = {};
  return e.replace(li, "").split(ri).forEach((n) => {
    if (n) {
      const o = n.split(ii);
      o.length > 1 && (t[o[0].trim()] = o[1].trim());
    }
  }), t;
}
function pt(e) {
  let t = "";
  if (ie(e))
    t = e;
  else if ($(e))
    for (let n = 0; n < e.length; n++) {
      const o = pt(e[n]);
      o && (t += o + " ");
    }
  else if (Z(e))
    for (const n in e)
      e[n] && (t += n + " ");
  return t.trim();
}
const ci = "itemscope,allowfullscreen,formnovalidate,ismap,nomodule,novalidate,readonly", ui = /* @__PURE__ */ go(ci);
function Xs(e) {
  return !!e || e === "";
}
const F = (e) => ie(e) ? e : e == null ? "" : $(e) || Z(e) && (e.toString === Ys || !W(e.toString)) ? JSON.stringify(e, js, 2) : String(e), js = (e, t) => t && t.__v_isRef ? js(e, t.value) : Ct(t) ? {
  [`Map(${t.size})`]: [...t.entries()].reduce((n, [o, s]) => (n[`${o} =>`] = s, n), {})
} : Fs(t) ? {
  [`Set(${t.size})`]: [...t.values()]
} : Z(t) && !$(t) && !Bs(t) ? String(t) : t;
let Me;
class fi {
  constructor(t = !1) {
    this.detached = t, this._active = !0, this.effects = [], this.cleanups = [], this.parent = Me, !t && Me && (this.index = (Me.scopes || (Me.scopes = [])).push(
      this
    ) - 1);
  }
  get active() {
    return this._active;
  }
  run(t) {
    if (this._active) {
      const n = Me;
      try {
        return Me = this, t();
      } finally {
        Me = n;
      }
    }
  }
  /**
   * This should only be called on non-detached scopes
   * @internal
   */
  on() {
    Me = this;
  }
  /**
   * This should only be called on non-detached scopes
   * @internal
   */
  off() {
    Me = this.parent;
  }
  stop(t) {
    if (this._active) {
      let n, o;
      for (n = 0, o = this.effects.length; n < o; n++)
        this.effects[n].stop();
      for (n = 0, o = this.cleanups.length; n < o; n++)
        this.cleanups[n]();
      if (this.scopes)
        for (n = 0, o = this.scopes.length; n < o; n++)
          this.scopes[n].stop(!0);
      if (!this.detached && this.parent && !t) {
        const s = this.parent.scopes.pop();
        s && s !== this && (this.parent.scopes[this.index] = s, s.index = this.index);
      }
      this.parent = void 0, this._active = !1;
    }
  }
}
function di(e, t = Me) {
  t && t.active && t.effects.push(e);
}
function pi() {
  return Me;
}
const wo = (e) => {
  const t = new Set(e);
  return t.w = 0, t.n = 0, t;
}, zs = (e) => (e.w & tt) > 0, qs = (e) => (e.n & tt) > 0, hi = ({ deps: e }) => {
  if (e.length)
    for (let t = 0; t < e.length; t++)
      e[t].w |= tt;
}, gi = (e) => {
  const { deps: t } = e;
  if (t.length) {
    let n = 0;
    for (let o = 0; o < t.length; o++) {
      const s = t[o];
      zs(s) && !qs(s) ? s.delete(e) : t[n++] = s, s.w &= ~tt, s.n &= ~tt;
    }
    t.length = n;
  }
}, bn = /* @__PURE__ */ new WeakMap();
let Nt = 0, tt = 1;
const Qn = 30;
let Oe;
const ht = Symbol(""), Gn = Symbol("");
class xo {
  constructor(t, n = null, o) {
    this.fn = t, this.scheduler = n, this.active = !0, this.deps = [], this.parent = void 0, di(this, o);
  }
  run() {
    if (!this.active)
      return this.fn();
    let t = Oe, n = Qe;
    for (; t; ) {
      if (t === this)
        return;
      t = t.parent;
    }
    try {
      return this.parent = Oe, Oe = this, Qe = !0, tt = 1 << ++Nt, Nt <= Qn ? hi(this) : zo(this), this.fn();
    } finally {
      Nt <= Qn && gi(this), tt = 1 << --Nt, Oe = this.parent, Qe = n, this.parent = void 0, this.deferStop && this.stop();
    }
  }
  stop() {
    Oe === this ? this.deferStop = !0 : this.active && (zo(this), this.onStop && this.onStop(), this.active = !1);
  }
}
function zo(e) {
  const { deps: t } = e;
  if (t.length) {
    for (let n = 0; n < t.length; n++)
      t[n].delete(e);
    t.length = 0;
  }
}
let Qe = !0;
const Ks = [];
function St() {
  Ks.push(Qe), Qe = !1;
}
function Pt() {
  const e = Ks.pop();
  Qe = e === void 0 ? !0 : e;
}
function ye(e, t, n) {
  if (Qe && Oe) {
    let o = bn.get(e);
    o || bn.set(e, o = /* @__PURE__ */ new Map());
    let s = o.get(n);
    s || o.set(n, s = wo()), Us(s);
  }
}
function Us(e, t) {
  let n = !1;
  Nt <= Qn ? qs(e) || (e.n |= tt, n = !zs(e)) : n = !e.has(Oe), n && (e.add(Oe), Oe.deps.push(e));
}
function je(e, t, n, o, s, r) {
  const i = bn.get(e);
  if (!i)
    return;
  let l = [];
  if (t === "clear")
    l = [...i.values()];
  else if (n === "length" && $(e)) {
    const a = Number(o);
    i.forEach((u, f) => {
      (f === "length" || f >= a) && l.push(u);
    });
  } else
    switch (n !== void 0 && l.push(i.get(n)), t) {
      case "add":
        $(e) ? vo(n) && l.push(i.get("length")) : (l.push(i.get(ht)), Ct(e) && l.push(i.get(Gn)));
        break;
      case "delete":
        $(e) || (l.push(i.get(ht)), Ct(e) && l.push(i.get(Gn)));
        break;
      case "set":
        Ct(e) && l.push(i.get(ht));
        break;
    }
  if (l.length === 1)
    l[0] && eo(l[0]);
  else {
    const a = [];
    for (const u of l)
      u && a.push(...u);
    eo(wo(a));
  }
}
function eo(e, t) {
  const n = $(e) ? e : [...e];
  for (const o of n)
    o.computed && qo(o);
  for (const o of n)
    o.computed || qo(o);
}
function qo(e, t) {
  (e !== Oe || e.allowRecurse) && (e.scheduler ? e.scheduler() : e.run());
}
function mi(e, t) {
  var n;
  return (n = bn.get(e)) == null ? void 0 : n.get(t);
}
const bi = /* @__PURE__ */ go("__proto__,__v_isRef,__isVue"), Vs = new Set(
  /* @__PURE__ */ Object.getOwnPropertyNames(Symbol).filter((e) => e !== "arguments" && e !== "caller").map((e) => Symbol[e]).filter(_o)
), _i = /* @__PURE__ */ ko(), vi = /* @__PURE__ */ ko(!1, !0), yi = /* @__PURE__ */ ko(!0), Ko = /* @__PURE__ */ wi();
function wi() {
  const e = {};
  return ["includes", "indexOf", "lastIndexOf"].forEach((t) => {
    e[t] = function(...n) {
      const o = B(this);
      for (let r = 0, i = this.length; r < i; r++)
        ye(o, "get", r + "");
      const s = o[t](...n);
      return s === -1 || s === !1 ? o[t](...n.map(B)) : s;
    };
  }), ["push", "pop", "shift", "unshift", "splice"].forEach((t) => {
    e[t] = function(...n) {
      St();
      const o = B(this)[t].apply(this, n);
      return Pt(), o;
    };
  }), e;
}
function xi(e) {
  const t = B(this);
  return ye(t, "has", e), t.hasOwnProperty(e);
}
function ko(e = !1, t = !1) {
  return function(o, s, r) {
    if (s === "__v_isReactive")
      return !e;
    if (s === "__v_isReadonly")
      return e;
    if (s === "__v_isShallow")
      return t;
    if (s === "__v_raw" && r === (e ? t ? Ni : er : t ? Gs : Qs).get(o))
      return o;
    const i = $(o);
    if (!e) {
      if (i && X(Ko, s))
        return Reflect.get(Ko, s, r);
      if (s === "hasOwnProperty")
        return xi;
    }
    const l = Reflect.get(o, s, r);
    return (_o(s) ? Vs.has(s) : bi(s)) || (e || ye(o, "get", s), t) ? l : de(l) ? i && vo(s) ? l : l.value : Z(l) ? e ? _n(l) : Ln(l) : l;
  };
}
const ki = /* @__PURE__ */ Js(), Ci = /* @__PURE__ */ Js(!0);
function Js(e = !1) {
  return function(n, o, s, r) {
    let i = n[o];
    if (Mt(i) && de(i) && !de(s))
      return !1;
    if (!e && (!vn(s) && !Mt(s) && (i = B(i), s = B(s)), !$(n) && de(i) && !de(s)))
      return i.value = s, !0;
    const l = $(n) && vo(o) ? Number(o) < n.length : X(n, o), a = Reflect.set(n, o, s, r);
    return n === B(r) && (l ? Kt(s, i) && je(n, "set", o, s) : je(n, "add", o, s)), a;
  };
}
function Ti(e, t) {
  const n = X(e, t);
  e[t];
  const o = Reflect.deleteProperty(e, t);
  return o && n && je(e, "delete", t, void 0), o;
}
function Ei(e, t) {
  const n = Reflect.has(e, t);
  return (!_o(t) || !Vs.has(t)) && ye(e, "has", t), n;
}
function Ai(e) {
  return ye(e, "iterate", $(e) ? "length" : ht), Reflect.ownKeys(e);
}
const Zs = {
  get: _i,
  set: ki,
  deleteProperty: Ti,
  has: Ei,
  ownKeys: Ai
}, Mi = {
  get: yi,
  set(e, t) {
    return !0;
  },
  deleteProperty(e, t) {
    return !0;
  }
}, Oi = /* @__PURE__ */ re(
  {},
  Zs,
  {
    get: vi,
    set: Ci
  }
), Co = (e) => e, On = (e) => Reflect.getPrototypeOf(e);
function nn(e, t, n = !1, o = !1) {
  e = e.__v_raw;
  const s = B(e), r = B(t);
  n || (t !== r && ye(s, "get", t), ye(s, "get", r));
  const { has: i } = On(s), l = o ? Co : n ? Ao : Ut;
  if (i.call(s, t))
    return l(e.get(t));
  if (i.call(s, r))
    return l(e.get(r));
  e !== s && e.get(t);
}
function on(e, t = !1) {
  const n = this.__v_raw, o = B(n), s = B(e);
  return t || (e !== s && ye(o, "has", e), ye(o, "has", s)), e === s ? n.has(e) : n.has(e) || n.has(s);
}
function sn(e, t = !1) {
  return e = e.__v_raw, !t && ye(B(e), "iterate", ht), Reflect.get(e, "size", e);
}
function Uo(e) {
  e = B(e);
  const t = B(this);
  return On(t).has.call(t, e) || (t.add(e), je(t, "add", e, e)), this;
}
function Vo(e, t) {
  t = B(t);
  const n = B(this), { has: o, get: s } = On(n);
  let r = o.call(n, e);
  r || (e = B(e), r = o.call(n, e));
  const i = s.call(n, e);
  return n.set(e, t), r ? Kt(t, i) && je(n, "set", e, t) : je(n, "add", e, t), this;
}
function Jo(e) {
  const t = B(this), { has: n, get: o } = On(t);
  let s = n.call(t, e);
  s || (e = B(e), s = n.call(t, e)), o && o.call(t, e);
  const r = t.delete(e);
  return s && je(t, "delete", e, void 0), r;
}
function Zo() {
  const e = B(this), t = e.size !== 0, n = e.clear();
  return t && je(e, "clear", void 0, void 0), n;
}
function rn(e, t) {
  return function(o, s) {
    const r = this, i = r.__v_raw, l = B(i), a = t ? Co : e ? Ao : Ut;
    return !e && ye(l, "iterate", ht), i.forEach((u, f) => o.call(s, a(u), a(f), r));
  };
}
function ln(e, t, n) {
  return function(...o) {
    const s = this.__v_raw, r = B(s), i = Ct(r), l = e === "entries" || e === Symbol.iterator && i, a = e === "keys" && i, u = s[e](...o), f = n ? Co : t ? Ao : Ut;
    return !t && ye(
      r,
      "iterate",
      a ? Gn : ht
    ), {
      // iterator protocol
      next() {
        const { value: h, done: p } = u.next();
        return p ? { value: h, done: p } : {
          value: l ? [f(h[0]), f(h[1])] : f(h),
          done: p
        };
      },
      // iterable protocol
      [Symbol.iterator]() {
        return this;
      }
    };
  };
}
function Ke(e) {
  return function(...t) {
    return e === "delete" ? !1 : this;
  };
}
function Li() {
  const e = {
    get(r) {
      return nn(this, r);
    },
    get size() {
      return sn(this);
    },
    has: on,
    add: Uo,
    set: Vo,
    delete: Jo,
    clear: Zo,
    forEach: rn(!1, !1)
  }, t = {
    get(r) {
      return nn(this, r, !1, !0);
    },
    get size() {
      return sn(this);
    },
    has: on,
    add: Uo,
    set: Vo,
    delete: Jo,
    clear: Zo,
    forEach: rn(!1, !0)
  }, n = {
    get(r) {
      return nn(this, r, !0);
    },
    get size() {
      return sn(this, !0);
    },
    has(r) {
      return on.call(this, r, !0);
    },
    add: Ke("add"),
    set: Ke("set"),
    delete: Ke("delete"),
    clear: Ke("clear"),
    forEach: rn(!0, !1)
  }, o = {
    get(r) {
      return nn(this, r, !0, !0);
    },
    get size() {
      return sn(this, !0);
    },
    has(r) {
      return on.call(this, r, !0);
    },
    add: Ke("add"),
    set: Ke("set"),
    delete: Ke("delete"),
    clear: Ke("clear"),
    forEach: rn(!0, !0)
  };
  return ["keys", "values", "entries", Symbol.iterator].forEach((r) => {
    e[r] = ln(
      r,
      !1,
      !1
    ), n[r] = ln(
      r,
      !0,
      !1
    ), t[r] = ln(
      r,
      !1,
      !0
    ), o[r] = ln(
      r,
      !0,
      !0
    );
  }), [
    e,
    n,
    t,
    o
  ];
}
const [
  Si,
  Pi,
  Ii,
  Ri
] = /* @__PURE__ */ Li();
function To(e, t) {
  const n = t ? e ? Ri : Ii : e ? Pi : Si;
  return (o, s, r) => s === "__v_isReactive" ? !e : s === "__v_isReadonly" ? e : s === "__v_raw" ? o : Reflect.get(
    X(n, s) && s in o ? n : o,
    s,
    r
  );
}
const Hi = {
  get: /* @__PURE__ */ To(!1, !1)
}, $i = {
  get: /* @__PURE__ */ To(!1, !0)
}, Di = {
  get: /* @__PURE__ */ To(!0, !1)
}, Qs = /* @__PURE__ */ new WeakMap(), Gs = /* @__PURE__ */ new WeakMap(), er = /* @__PURE__ */ new WeakMap(), Ni = /* @__PURE__ */ new WeakMap();
function Fi(e) {
  switch (e) {
    case "Object":
    case "Array":
      return 1;
    case "Map":
    case "Set":
    case "WeakMap":
    case "WeakSet":
      return 2;
    default:
      return 0;
  }
}
function Wi(e) {
  return e.__v_skip || !Object.isExtensible(e) ? 0 : Fi(ei(e));
}
function Ln(e) {
  return Mt(e) ? e : Eo(
    e,
    !1,
    Zs,
    Hi,
    Qs
  );
}
function Yi(e) {
  return Eo(
    e,
    !1,
    Oi,
    $i,
    Gs
  );
}
function _n(e) {
  return Eo(
    e,
    !0,
    Mi,
    Di,
    er
  );
}
function Eo(e, t, n, o, s) {
  if (!Z(e) || e.__v_raw && !(t && e.__v_isReactive))
    return e;
  const r = s.get(e);
  if (r)
    return r;
  const i = Wi(e);
  if (i === 0)
    return e;
  const l = new Proxy(
    e,
    i === 2 ? o : n
  );
  return s.set(e, l), l;
}
function Tt(e) {
  return Mt(e) ? Tt(e.__v_raw) : !!(e && e.__v_isReactive);
}
function Mt(e) {
  return !!(e && e.__v_isReadonly);
}
function vn(e) {
  return !!(e && e.__v_isShallow);
}
function tr(e) {
  return Tt(e) || Mt(e);
}
function B(e) {
  const t = e && e.__v_raw;
  return t ? B(t) : e;
}
function nr(e) {
  return mn(e, "__v_skip", !0), e;
}
const Ut = (e) => Z(e) ? Ln(e) : e, Ao = (e) => Z(e) ? _n(e) : e;
function or(e) {
  Qe && Oe && (e = B(e), Us(e.dep || (e.dep = wo())));
}
function sr(e, t) {
  e = B(e);
  const n = e.dep;
  n && eo(n);
}
function de(e) {
  return !!(e && e.__v_isRef === !0);
}
function Be(e) {
  return Bi(e, !1);
}
function Bi(e, t) {
  return de(e) ? e : new Xi(e, t);
}
class Xi {
  constructor(t, n) {
    this.__v_isShallow = n, this.dep = void 0, this.__v_isRef = !0, this._rawValue = n ? t : B(t), this._value = n ? t : Ut(t);
  }
  get value() {
    return or(this), this._value;
  }
  set value(t) {
    const n = this.__v_isShallow || vn(t) || Mt(t);
    t = n ? t : B(t), Kt(t, this._rawValue) && (this._rawValue = t, this._value = n ? t : Ut(t), sr(this));
  }
}
function rr(e) {
  return de(e) ? e.value : e;
}
const ji = {
  get: (e, t, n) => rr(Reflect.get(e, t, n)),
  set: (e, t, n, o) => {
    const s = e[t];
    return de(s) && !de(n) ? (s.value = n, !0) : Reflect.set(e, t, n, o);
  }
};
function ir(e) {
  return Tt(e) ? e : new Proxy(e, ji);
}
function an(e) {
  const t = $(e) ? new Array(e.length) : {};
  for (const n in e)
    t[n] = qi(e, n);
  return t;
}
class zi {
  constructor(t, n, o) {
    this._object = t, this._key = n, this._defaultValue = o, this.__v_isRef = !0;
  }
  get value() {
    const t = this._object[this._key];
    return t === void 0 ? this._defaultValue : t;
  }
  set value(t) {
    this._object[this._key] = t;
  }
  get dep() {
    return mi(B(this._object), this._key);
  }
}
function qi(e, t, n) {
  const o = e[t];
  return de(o) ? o : new zi(
    e,
    t,
    n
  );
}
class Ki {
  constructor(t, n, o, s) {
    this._setter = n, this.dep = void 0, this.__v_isRef = !0, this.__v_isReadonly = !1, this._dirty = !0, this.effect = new xo(t, () => {
      this._dirty || (this._dirty = !0, sr(this));
    }), this.effect.computed = this, this.effect.active = this._cacheable = !s, this.__v_isReadonly = o;
  }
  get value() {
    const t = B(this);
    return or(t), (t._dirty || !t._cacheable) && (t._dirty = !1, t._value = t.effect.run()), t._value;
  }
  set value(t) {
    this._setter(t);
  }
}
function Ui(e, t, n = !1) {
  let o, s;
  const r = W(e);
  return r ? (o = e, s = Se) : (o = e.get, s = e.set), new Ki(o, s, r || !s, n);
}
function Ge(e, t, n, o) {
  let s;
  try {
    s = o ? e(...o) : e();
  } catch (r) {
    Sn(r, t, n);
  }
  return s;
}
function Te(e, t, n, o) {
  if (W(e)) {
    const r = Ge(e, t, n, o);
    return r && Ws(r) && r.catch((i) => {
      Sn(i, t, n);
    }), r;
  }
  const s = [];
  for (let r = 0; r < e.length; r++)
    s.push(Te(e[r], t, n, o));
  return s;
}
function Sn(e, t, n, o = !0) {
  const s = t ? t.vnode : null;
  if (t) {
    let r = t.parent;
    const i = t.proxy, l = n;
    for (; r; ) {
      const u = r.ec;
      if (u) {
        for (let f = 0; f < u.length; f++)
          if (u[f](e, i, l) === !1)
            return;
      }
      r = r.parent;
    }
    const a = t.appContext.config.errorHandler;
    if (a) {
      Ge(
        a,
        null,
        10,
        [e, i, l]
      );
      return;
    }
  }
  Vi(e, n, s, o);
}
function Vi(e, t, n, o = !0) {
  console.error(e);
}
let Vt = !1, to = !1;
const he = [];
let $e = 0;
const Et = [];
let We = null, ct = 0;
const lr = /* @__PURE__ */ Promise.resolve();
let Mo = null;
function Ji(e) {
  const t = Mo || lr;
  return e ? t.then(this ? e.bind(this) : e) : t;
}
function Zi(e) {
  let t = $e + 1, n = he.length;
  for (; t < n; ) {
    const o = t + n >>> 1;
    Jt(he[o]) < e ? t = o + 1 : n = o;
  }
  return t;
}
function Oo(e) {
  (!he.length || !he.includes(
    e,
    Vt && e.allowRecurse ? $e + 1 : $e
  )) && (e.id == null ? he.push(e) : he.splice(Zi(e.id), 0, e), ar());
}
function ar() {
  !Vt && !to && (to = !0, Mo = lr.then(ur));
}
function Qi(e) {
  const t = he.indexOf(e);
  t > $e && he.splice(t, 1);
}
function Gi(e) {
  $(e) ? Et.push(...e) : (!We || !We.includes(
    e,
    e.allowRecurse ? ct + 1 : ct
  )) && Et.push(e), ar();
}
function Qo(e, t = Vt ? $e + 1 : 0) {
  for (; t < he.length; t++) {
    const n = he[t];
    n && n.pre && (he.splice(t, 1), t--, n());
  }
}
function cr(e) {
  if (Et.length) {
    const t = [...new Set(Et)];
    if (Et.length = 0, We) {
      We.push(...t);
      return;
    }
    for (We = t, We.sort((n, o) => Jt(n) - Jt(o)), ct = 0; ct < We.length; ct++)
      We[ct]();
    We = null, ct = 0;
  }
}
const Jt = (e) => e.id == null ? 1 / 0 : e.id, el = (e, t) => {
  const n = Jt(e) - Jt(t);
  if (n === 0) {
    if (e.pre && !t.pre)
      return -1;
    if (t.pre && !e.pre)
      return 1;
  }
  return n;
};
function ur(e) {
  to = !1, Vt = !0, he.sort(el);
  const t = Se;
  try {
    for ($e = 0; $e < he.length; $e++) {
      const n = he[$e];
      n && n.active !== !1 && Ge(n, null, 14);
    }
  } finally {
    $e = 0, he.length = 0, cr(), Vt = !1, Mo = null, (he.length || Et.length) && ur();
  }
}
function tl(e, t, ...n) {
  if (e.isUnmounted)
    return;
  const o = e.vnode.props || J;
  let s = n;
  const r = t.startsWith("update:"), i = r && t.slice(7);
  if (i && i in o) {
    const f = `${i === "modelValue" ? "model" : i}Modifiers`, { number: h, trim: p } = o[f] || J;
    p && (s = n.map((w) => ie(w) ? w.trim() : w)), h && (s = n.map(oi));
  }
  let l, a = o[l = Yn(t)] || // also try camelCase event handler (#2249)
  o[l = Yn(Ne(t))];
  !a && r && (a = o[l = Yn(bt(t))]), a && Te(
    a,
    e,
    6,
    s
  );
  const u = o[l + "Once"];
  if (u) {
    if (!e.emitted)
      e.emitted = {};
    else if (e.emitted[l])
      return;
    e.emitted[l] = !0, Te(
      u,
      e,
      6,
      s
    );
  }
}
function fr(e, t, n = !1) {
  const o = t.emitsCache, s = o.get(e);
  if (s !== void 0)
    return s;
  const r = e.emits;
  let i = {}, l = !1;
  if (!W(e)) {
    const a = (u) => {
      const f = fr(u, t, !0);
      f && (l = !0, re(i, f));
    };
    !n && t.mixins.length && t.mixins.forEach(a), e.extends && a(e.extends), e.mixins && e.mixins.forEach(a);
  }
  return !r && !l ? (Z(e) && o.set(e, null), null) : ($(r) ? r.forEach((a) => i[a] = null) : re(i, r), Z(e) && o.set(e, i), i);
}
function Pn(e, t) {
  return !e || !Tn(t) ? !1 : (t = t.slice(2).replace(/Once$/, ""), X(e, t[0].toLowerCase() + t.slice(1)) || X(e, bt(t)) || X(e, t));
}
let pe = null, dr = null;
function yn(e) {
  const t = pe;
  return pe = e, dr = e && e.type.__scopeId || null, t;
}
function fe(e, t = pe, n) {
  if (!t || e._n)
    return e;
  const o = (...s) => {
    o._d && fs(-1);
    const r = yn(t);
    let i;
    try {
      i = e(...s);
    } finally {
      yn(r), o._d && fs(1);
    }
    return i;
  };
  return o._n = !0, o._c = !0, o._d = !0, o;
}
function Xn(e) {
  const {
    type: t,
    vnode: n,
    proxy: o,
    withProxy: s,
    props: r,
    propsOptions: [i],
    slots: l,
    attrs: a,
    emit: u,
    render: f,
    renderCache: h,
    data: p,
    setupState: w,
    ctx: v,
    inheritAttrs: y
  } = e;
  let R, T;
  const E = yn(e);
  try {
    if (n.shapeFlag & 4) {
      const O = s || o;
      R = He(
        f.call(
          O,
          O,
          h,
          r,
          w,
          p,
          v
        )
      ), T = a;
    } else {
      const O = t;
      R = He(
        O.length > 1 ? O(
          r,
          { attrs: a, slots: l, emit: u }
        ) : O(
          r,
          null
          /* we know it doesn't need it */
        )
      ), T = t.props ? a : nl(a);
    }
  } catch (O) {
    qt.length = 0, Sn(O, e, 1), R = te(Ee);
  }
  let H = R;
  if (T && y !== !1) {
    const O = Object.keys(T), { shapeFlag: V } = H;
    O.length && V & 7 && (i && O.some(mo) && (T = ol(
      T,
      i
    )), H = nt(H, T));
  }
  return n.dirs && (H = nt(H), H.dirs = H.dirs ? H.dirs.concat(n.dirs) : n.dirs), n.transition && (H.transition = n.transition), R = H, yn(E), R;
}
const nl = (e) => {
  let t;
  for (const n in e)
    (n === "class" || n === "style" || Tn(n)) && ((t || (t = {}))[n] = e[n]);
  return t;
}, ol = (e, t) => {
  const n = {};
  for (const o in e)
    (!mo(o) || !(o.slice(9) in t)) && (n[o] = e[o]);
  return n;
};
function sl(e, t, n) {
  const { props: o, children: s, component: r } = e, { props: i, children: l, patchFlag: a } = t, u = r.emitsOptions;
  if (t.dirs || t.transition)
    return !0;
  if (n && a >= 0) {
    if (a & 1024)
      return !0;
    if (a & 16)
      return o ? Go(o, i, u) : !!i;
    if (a & 8) {
      const f = t.dynamicProps;
      for (let h = 0; h < f.length; h++) {
        const p = f[h];
        if (i[p] !== o[p] && !Pn(u, p))
          return !0;
      }
    }
  } else
    return (s || l) && (!l || !l.$stable) ? !0 : o === i ? !1 : o ? i ? Go(o, i, u) : !0 : !!i;
  return !1;
}
function Go(e, t, n) {
  const o = Object.keys(t);
  if (o.length !== Object.keys(e).length)
    return !0;
  for (let s = 0; s < o.length; s++) {
    const r = o[s];
    if (t[r] !== e[r] && !Pn(n, r))
      return !0;
  }
  return !1;
}
function rl({ vnode: e, parent: t }, n) {
  for (; t && t.subTree === e; )
    (e = t.vnode).el = n, t = t.parent;
}
const il = (e) => e.__isSuspense;
function ll(e, t) {
  t && t.pendingBranch ? $(e) ? t.effects.push(...e) : t.effects.push(e) : Gi(e);
}
const cn = {};
function hn(e, t, n) {
  return pr(e, t, n);
}
function pr(e, t, { immediate: n, deep: o, flush: s, onTrack: r, onTrigger: i } = J) {
  var l;
  const a = pi() === ((l = ce) == null ? void 0 : l.scope) ? ce : null;
  let u, f = !1, h = !1;
  if (de(e) ? (u = () => e.value, f = vn(e)) : Tt(e) ? (u = () => e, o = !0) : $(e) ? (h = !0, f = e.some((O) => Tt(O) || vn(O)), u = () => e.map((O) => {
    if (de(O))
      return O.value;
    if (Tt(O))
      return dt(O);
    if (W(O))
      return Ge(O, a, 2);
  })) : W(e) ? t ? u = () => Ge(e, a, 2) : u = () => {
    if (!(a && a.isUnmounted))
      return p && p(), Te(
        e,
        a,
        3,
        [w]
      );
  } : u = Se, t && o) {
    const O = u;
    u = () => dt(O());
  }
  let p, w = (O) => {
    p = E.onStop = () => {
      Ge(O, a, 4);
    };
  }, v;
  if (Qt)
    if (w = Se, t ? n && Te(t, a, 3, [
      u(),
      h ? [] : void 0,
      w
    ]) : u(), s === "sync") {
      const O = sa();
      v = O.__watcherHandles || (O.__watcherHandles = []);
    } else
      return Se;
  let y = h ? new Array(e.length).fill(cn) : cn;
  const R = () => {
    if (E.active)
      if (t) {
        const O = E.run();
        (o || f || (h ? O.some(
          (V, ue) => Kt(V, y[ue])
        ) : Kt(O, y))) && (p && p(), Te(t, a, 3, [
          O,
          // pass undefined as the old value when it's changed for the first time
          y === cn ? void 0 : h && y[0] === cn ? [] : y,
          w
        ]), y = O);
      } else
        E.run();
  };
  R.allowRecurse = !!t;
  let T;
  s === "sync" ? T = R : s === "post" ? T = () => _e(R, a && a.suspense) : (R.pre = !0, a && (R.id = a.uid), T = () => Oo(R));
  const E = new xo(u, T);
  t ? n ? R() : y = E.run() : s === "post" ? _e(
    E.run.bind(E),
    a && a.suspense
  ) : E.run();
  const H = () => {
    E.stop(), a && a.scope && bo(a.scope.effects, E);
  };
  return v && v.push(H), H;
}
function al(e, t, n) {
  const o = this.proxy, s = ie(e) ? e.includes(".") ? hr(o, e) : () => o[e] : e.bind(o, o);
  let r;
  W(t) ? r = t : (r = t.handler, n = t);
  const i = ce;
  Ot(this);
  const l = pr(s, r.bind(o), n);
  return i ? Ot(i) : mt(), l;
}
function hr(e, t) {
  const n = t.split(".");
  return () => {
    let o = e;
    for (let s = 0; s < n.length && o; s++)
      o = o[n[s]];
    return o;
  };
}
function dt(e, t) {
  if (!Z(e) || e.__v_skip || (t = t || /* @__PURE__ */ new Set(), t.has(e)))
    return e;
  if (t.add(e), de(e))
    dt(e.value, t);
  else if ($(e))
    for (let n = 0; n < e.length; n++)
      dt(e[n], t);
  else if (Fs(e) || Ct(e))
    e.forEach((n) => {
      dt(n, t);
    });
  else if (Bs(e))
    for (const n in e)
      dt(e[n], t);
  return e;
}
function no(e, t) {
  const n = pe;
  if (n === null)
    return e;
  const o = Nn(n) || n.proxy, s = e.dirs || (e.dirs = []);
  for (let r = 0; r < t.length; r++) {
    let [i, l, a, u = J] = t[r];
    i && (W(i) && (i = {
      mounted: i,
      updated: i
    }), i.deep && dt(l), s.push({
      dir: i,
      instance: o,
      value: l,
      oldValue: void 0,
      arg: a,
      modifiers: u
    }));
  }
  return e;
}
function rt(e, t, n, o) {
  const s = e.dirs, r = t && t.dirs;
  for (let i = 0; i < s.length; i++) {
    const l = s[i];
    r && (l.oldValue = r[i].value);
    let a = l.dir[o];
    a && (St(), Te(a, n, 8, [
      e.el,
      l,
      e,
      t
    ]), Pt());
  }
}
function cl() {
  const e = {
    isMounted: !1,
    isLeaving: !1,
    isUnmounting: !1,
    leavingVNodes: /* @__PURE__ */ new Map()
  };
  return Hn(() => {
    e.isMounted = !0;
  }), So(() => {
    e.isUnmounting = !0;
  }), e;
}
const ke = [Function, Array], gr = {
  mode: String,
  appear: Boolean,
  persisted: Boolean,
  // enter
  onBeforeEnter: ke,
  onEnter: ke,
  onAfterEnter: ke,
  onEnterCancelled: ke,
  // leave
  onBeforeLeave: ke,
  onLeave: ke,
  onAfterLeave: ke,
  onLeaveCancelled: ke,
  // appear
  onBeforeAppear: ke,
  onAppear: ke,
  onAfterAppear: ke,
  onAppearCancelled: ke
}, ul = {
  name: "BaseTransition",
  props: gr,
  setup(e, { slots: t }) {
    const n = Vl(), o = cl();
    let s;
    return () => {
      const r = t.default && br(t.default(), !0);
      if (!r || !r.length)
        return;
      let i = r[0];
      if (r.length > 1) {
        for (const y of r)
          if (y.type !== Ee) {
            i = y;
            break;
          }
      }
      const l = B(e), { mode: a } = l;
      if (o.isLeaving)
        return jn(i);
      const u = es(i);
      if (!u)
        return jn(i);
      const f = oo(
        u,
        l,
        o,
        n
      );
      so(u, f);
      const h = n.subTree, p = h && es(h);
      let w = !1;
      const { getTransitionKey: v } = u.type;
      if (v) {
        const y = v();
        s === void 0 ? s = y : y !== s && (s = y, w = !0);
      }
      if (p && p.type !== Ee && (!ut(u, p) || w)) {
        const y = oo(
          p,
          l,
          o,
          n
        );
        if (so(p, y), a === "out-in")
          return o.isLeaving = !0, y.afterLeave = () => {
            o.isLeaving = !1, n.update.active !== !1 && n.update();
          }, jn(i);
        a === "in-out" && u.type !== Ee && (y.delayLeave = (R, T, E) => {
          const H = mr(
            o,
            p
          );
          H[String(p.key)] = p, R._leaveCb = () => {
            T(), R._leaveCb = void 0, delete f.delayedLeave;
          }, f.delayedLeave = E;
        });
      }
      return i;
    };
  }
}, fl = ul;
function mr(e, t) {
  const { leavingVNodes: n } = e;
  let o = n.get(t.type);
  return o || (o = /* @__PURE__ */ Object.create(null), n.set(t.type, o)), o;
}
function oo(e, t, n, o) {
  const {
    appear: s,
    mode: r,
    persisted: i = !1,
    onBeforeEnter: l,
    onEnter: a,
    onAfterEnter: u,
    onEnterCancelled: f,
    onBeforeLeave: h,
    onLeave: p,
    onAfterLeave: w,
    onLeaveCancelled: v,
    onBeforeAppear: y,
    onAppear: R,
    onAfterAppear: T,
    onAppearCancelled: E
  } = t, H = String(e.key), O = mr(n, e), V = (D, z) => {
    D && Te(
      D,
      o,
      9,
      z
    );
  }, ue = (D, z) => {
    const j = z[1];
    V(D, z), $(D) ? D.every((ne) => ne.length <= 1) && j() : D.length <= 1 && j();
  }, le = {
    mode: r,
    persisted: i,
    beforeEnter(D) {
      let z = l;
      if (!n.isMounted)
        if (s)
          z = y || l;
        else
          return;
      D._leaveCb && D._leaveCb(
        !0
        /* cancelled */
      );
      const j = O[H];
      j && ut(e, j) && j.el._leaveCb && j.el._leaveCb(), V(z, [D]);
    },
    enter(D) {
      let z = a, j = u, ne = f;
      if (!n.isMounted)
        if (s)
          z = R || a, j = T || u, ne = E || f;
        else
          return;
      let S = !1;
      const Q = D._enterCb = (we) => {
        S || (S = !0, we ? V(ne, [D]) : V(j, [D]), le.delayedLeave && le.delayedLeave(), D._enterCb = void 0);
      };
      z ? ue(z, [D, Q]) : Q();
    },
    leave(D, z) {
      const j = String(e.key);
      if (D._enterCb && D._enterCb(
        !0
        /* cancelled */
      ), n.isUnmounting)
        return z();
      V(h, [D]);
      let ne = !1;
      const S = D._leaveCb = (Q) => {
        ne || (ne = !0, z(), Q ? V(v, [D]) : V(w, [D]), D._leaveCb = void 0, O[j] === e && delete O[j]);
      };
      O[j] = e, p ? ue(p, [D, S]) : S();
    },
    clone(D) {
      return oo(D, t, n, o);
    }
  };
  return le;
}
function jn(e) {
  if (In(e))
    return e = nt(e), e.children = null, e;
}
function es(e) {
  return In(e) ? e.children ? e.children[0] : void 0 : e;
}
function so(e, t) {
  e.shapeFlag & 6 && e.component ? so(e.component.subTree, t) : e.shapeFlag & 128 ? (e.ssContent.transition = t.clone(e.ssContent), e.ssFallback.transition = t.clone(e.ssFallback)) : e.transition = t;
}
function br(e, t = !1, n) {
  let o = [], s = 0;
  for (let r = 0; r < e.length; r++) {
    let i = e[r];
    const l = n == null ? i.key : String(n) + String(i.key != null ? i.key : r);
    i.type === Ce ? (i.patchFlag & 128 && s++, o = o.concat(
      br(i.children, t, l)
    )) : (t || i.type !== Ee) && o.push(l != null ? nt(i, { key: l }) : i);
  }
  if (s > 1)
    for (let r = 0; r < o.length; r++)
      o[r].patchFlag = -2;
  return o;
}
function Lo(e, t) {
  return W(e) ? (
    // #8326: extend call and options.name access are considered side-effects
    // by Rollup, so we have to wrap it in a pure-annotated IIFE.
    /* @__PURE__ */ (() => re({ name: e.name }, t, { setup: e }))()
  ) : e;
}
const Bt = (e) => !!e.type.__asyncLoader, In = (e) => e.type.__isKeepAlive;
function dl(e, t) {
  _r(e, "a", t);
}
function pl(e, t) {
  _r(e, "da", t);
}
function _r(e, t, n = ce) {
  const o = e.__wdc || (e.__wdc = () => {
    let s = n;
    for (; s; ) {
      if (s.isDeactivated)
        return;
      s = s.parent;
    }
    return e();
  });
  if (Rn(t, o, n), n) {
    let s = n.parent;
    for (; s && s.parent; )
      In(s.parent.vnode) && hl(o, t, n, s), s = s.parent;
  }
}
function hl(e, t, n, o) {
  const s = Rn(
    t,
    e,
    o,
    !0
    /* prepend */
  );
  vr(() => {
    bo(o[t], s);
  }, n);
}
function Rn(e, t, n = ce, o = !1) {
  if (n) {
    const s = n[e] || (n[e] = []), r = t.__weh || (t.__weh = (...i) => {
      if (n.isUnmounted)
        return;
      St(), Ot(n);
      const l = Te(t, n, e, i);
      return mt(), Pt(), l;
    });
    return o ? s.unshift(r) : s.push(r), r;
  }
}
const qe = (e) => (t, n = ce) => (
  // post-create lifecycle registrations are noops during SSR (except for serverPrefetch)
  (!Qt || e === "sp") && Rn(e, (...o) => t(...o), n)
), gl = qe("bm"), Hn = qe("m"), ml = qe("bu"), bl = qe("u"), So = qe("bum"), vr = qe("um"), yr = qe("sp"), _l = qe(
  "rtg"
), vl = qe(
  "rtc"
);
function yl(e, t = ce) {
  Rn("ec", e, t);
}
const wr = "components";
function Ft(e, t) {
  return xl(wr, e, !0, t) || e;
}
const wl = Symbol.for("v-ndc");
function xl(e, t, n = !0, o = !1) {
  const s = pe || ce;
  if (s) {
    const r = s.type;
    if (e === wr) {
      const l = ea(
        r,
        !1
        /* do not include inferred name to avoid breaking existing code */
      );
      if (l && (l === t || l === Ne(t) || l === Mn(Ne(t))))
        return r;
    }
    const i = (
      // local registration
      // check instance[type] first which is resolved for options API
      ts(s[e] || r[e], t) || // global registration
      ts(s.appContext[e], t)
    );
    return !i && o ? r : i;
  }
}
function ts(e, t) {
  return e && (e[t] || e[Ne(t)] || e[Mn(Ne(t))]);
}
function At(e, t, n = {}, o, s) {
  if (pe.isCE || pe.parent && Bt(pe.parent) && pe.parent.isCE)
    return t !== "default" && (n.name = t), te("slot", n, o && o());
  let r = e[t];
  r && r._c && (r._d = !1), be();
  const i = r && xr(r(n)), l = gt(
    Ce,
    {
      key: n.key || // slot content array of a dynamic conditional slot may have a branch
      // key attached in the `createSlots` helper, respect that
      i && i.key || `_${t}`
    },
    i || (o ? o() : []),
    i && e._ === 1 ? 64 : -2
  );
  return !s && l.scopeId && (l.slotScopeIds = [l.scopeId + "-s"]), r && r._c && (r._d = !0), l;
}
function xr(e) {
  return e.some((t) => kn(t) ? !(t.type === Ee || t.type === Ce && !xr(t.children)) : !0) ? e : null;
}
const ro = (e) => e ? Hr(e) ? Nn(e) || e.proxy : ro(e.parent) : null, Xt = (
  // Move PURE marker to new line to workaround compiler discarding it
  // due to type annotation
  /* @__PURE__ */ re(/* @__PURE__ */ Object.create(null), {
    $: (e) => e,
    $el: (e) => e.vnode.el,
    $data: (e) => e.data,
    $props: (e) => e.props,
    $attrs: (e) => e.attrs,
    $slots: (e) => e.slots,
    $refs: (e) => e.refs,
    $parent: (e) => ro(e.parent),
    $root: (e) => ro(e.root),
    $emit: (e) => e.emit,
    $options: (e) => Po(e),
    $forceUpdate: (e) => e.f || (e.f = () => Oo(e.update)),
    $nextTick: (e) => e.n || (e.n = Ji.bind(e.proxy)),
    $watch: (e) => al.bind(e)
  })
), zn = (e, t) => e !== J && !e.__isScriptSetup && X(e, t), kl = {
  get({ _: e }, t) {
    const { ctx: n, setupState: o, data: s, props: r, accessCache: i, type: l, appContext: a } = e;
    let u;
    if (t[0] !== "$") {
      const w = i[t];
      if (w !== void 0)
        switch (w) {
          case 1:
            return o[t];
          case 2:
            return s[t];
          case 4:
            return n[t];
          case 3:
            return r[t];
        }
      else {
        if (zn(o, t))
          return i[t] = 1, o[t];
        if (s !== J && X(s, t))
          return i[t] = 2, s[t];
        if (
          // only cache other properties when instance has declared (thus stable)
          // props
          (u = e.propsOptions[0]) && X(u, t)
        )
          return i[t] = 3, r[t];
        if (n !== J && X(n, t))
          return i[t] = 4, n[t];
        io && (i[t] = 0);
      }
    }
    const f = Xt[t];
    let h, p;
    if (f)
      return t === "$attrs" && ye(e, "get", t), f(e);
    if (
      // css module (injected by vue-loader)
      (h = l.__cssModules) && (h = h[t])
    )
      return h;
    if (n !== J && X(n, t))
      return i[t] = 4, n[t];
    if (
      // global properties
      p = a.config.globalProperties, X(p, t)
    )
      return p[t];
  },
  set({ _: e }, t, n) {
    const { data: o, setupState: s, ctx: r } = e;
    return zn(s, t) ? (s[t] = n, !0) : o !== J && X(o, t) ? (o[t] = n, !0) : X(e.props, t) || t[0] === "$" && t.slice(1) in e ? !1 : (r[t] = n, !0);
  },
  has({
    _: { data: e, setupState: t, accessCache: n, ctx: o, appContext: s, propsOptions: r }
  }, i) {
    let l;
    return !!n[i] || e !== J && X(e, i) || zn(t, i) || (l = r[0]) && X(l, i) || X(o, i) || X(Xt, i) || X(s.config.globalProperties, i);
  },
  defineProperty(e, t, n) {
    return n.get != null ? e._.accessCache[t] = 0 : X(n, "value") && this.set(e, t, n.value, null), Reflect.defineProperty(e, t, n);
  }
};
function ns(e) {
  return $(e) ? e.reduce(
    (t, n) => (t[n] = null, t),
    {}
  ) : e;
}
let io = !0;
function Cl(e) {
  const t = Po(e), n = e.proxy, o = e.ctx;
  io = !1, t.beforeCreate && os(t.beforeCreate, e, "bc");
  const {
    // state
    data: s,
    computed: r,
    methods: i,
    watch: l,
    provide: a,
    inject: u,
    // lifecycle
    created: f,
    beforeMount: h,
    mounted: p,
    beforeUpdate: w,
    updated: v,
    activated: y,
    deactivated: R,
    beforeDestroy: T,
    beforeUnmount: E,
    destroyed: H,
    unmounted: O,
    render: V,
    renderTracked: ue,
    renderTriggered: le,
    errorCaptured: D,
    serverPrefetch: z,
    // public API
    expose: j,
    inheritAttrs: ne,
    // assets
    components: S,
    directives: Q,
    filters: we
  } = t;
  if (u && Tl(u, o, null), i)
    for (const ee in i) {
      const K = i[ee];
      W(K) && (o[ee] = K.bind(n));
    }
  if (s) {
    const ee = s.call(n, n);
    Z(ee) && (e.data = Ln(ee));
  }
  if (io = !0, r)
    for (const ee in r) {
      const K = r[ee], ot = W(K) ? K.bind(n, n) : W(K.get) ? K.get.bind(n, n) : Se, en = !W(K) && W(K.set) ? K.set.bind(n) : Se, st = Xe({
        get: ot,
        set: en
      });
      Object.defineProperty(o, ee, {
        enumerable: !0,
        configurable: !0,
        get: () => st.value,
        set: (Pe) => st.value = Pe
      });
    }
  if (l)
    for (const ee in l)
      kr(l[ee], o, n, ee);
  if (a) {
    const ee = W(a) ? a.call(n) : a;
    Reflect.ownKeys(ee).forEach((K) => {
      Tr(K, ee[K]);
    });
  }
  f && os(f, e, "c");
  function ae(ee, K) {
    $(K) ? K.forEach((ot) => ee(ot.bind(n))) : K && ee(K.bind(n));
  }
  if (ae(gl, h), ae(Hn, p), ae(ml, w), ae(bl, v), ae(dl, y), ae(pl, R), ae(yl, D), ae(vl, ue), ae(_l, le), ae(So, E), ae(vr, O), ae(yr, z), $(j))
    if (j.length) {
      const ee = e.exposed || (e.exposed = {});
      j.forEach((K) => {
        Object.defineProperty(ee, K, {
          get: () => n[K],
          set: (ot) => n[K] = ot
        });
      });
    } else
      e.exposed || (e.exposed = {});
  V && e.render === Se && (e.render = V), ne != null && (e.inheritAttrs = ne), S && (e.components = S), Q && (e.directives = Q);
}
function Tl(e, t, n = Se) {
  $(e) && (e = lo(e));
  for (const o in e) {
    const s = e[o];
    let r;
    Z(s) ? "default" in s ? r = jt(
      s.from || o,
      s.default,
      !0
      /* treat default function as factory */
    ) : r = jt(s.from || o) : r = jt(s), de(r) ? Object.defineProperty(t, o, {
      enumerable: !0,
      configurable: !0,
      get: () => r.value,
      set: (i) => r.value = i
    }) : t[o] = r;
  }
}
function os(e, t, n) {
  Te(
    $(e) ? e.map((o) => o.bind(t.proxy)) : e.bind(t.proxy),
    t,
    n
  );
}
function kr(e, t, n, o) {
  const s = o.includes(".") ? hr(n, o) : () => n[o];
  if (ie(e)) {
    const r = t[e];
    W(r) && hn(s, r);
  } else if (W(e))
    hn(s, e.bind(n));
  else if (Z(e))
    if ($(e))
      e.forEach((r) => kr(r, t, n, o));
    else {
      const r = W(e.handler) ? e.handler.bind(n) : t[e.handler];
      W(r) && hn(s, r, e);
    }
}
function Po(e) {
  const t = e.type, { mixins: n, extends: o } = t, {
    mixins: s,
    optionsCache: r,
    config: { optionMergeStrategies: i }
  } = e.appContext, l = r.get(t);
  let a;
  return l ? a = l : !s.length && !n && !o ? a = t : (a = {}, s.length && s.forEach(
    (u) => wn(a, u, i, !0)
  ), wn(a, t, i)), Z(t) && r.set(t, a), a;
}
function wn(e, t, n, o = !1) {
  const { mixins: s, extends: r } = t;
  r && wn(e, r, n, !0), s && s.forEach(
    (i) => wn(e, i, n, !0)
  );
  for (const i in t)
    if (!(o && i === "expose")) {
      const l = El[i] || n && n[i];
      e[i] = l ? l(e[i], t[i]) : t[i];
    }
  return e;
}
const El = {
  data: ss,
  props: rs,
  emits: rs,
  // objects
  methods: Wt,
  computed: Wt,
  // lifecycle
  beforeCreate: ge,
  created: ge,
  beforeMount: ge,
  mounted: ge,
  beforeUpdate: ge,
  updated: ge,
  beforeDestroy: ge,
  beforeUnmount: ge,
  destroyed: ge,
  unmounted: ge,
  activated: ge,
  deactivated: ge,
  errorCaptured: ge,
  serverPrefetch: ge,
  // assets
  components: Wt,
  directives: Wt,
  // watch
  watch: Ml,
  // provide / inject
  provide: ss,
  inject: Al
};
function ss(e, t) {
  return t ? e ? function() {
    return re(
      W(e) ? e.call(this, this) : e,
      W(t) ? t.call(this, this) : t
    );
  } : t : e;
}
function Al(e, t) {
  return Wt(lo(e), lo(t));
}
function lo(e) {
  if ($(e)) {
    const t = {};
    for (let n = 0; n < e.length; n++)
      t[e[n]] = e[n];
    return t;
  }
  return e;
}
function ge(e, t) {
  return e ? [...new Set([].concat(e, t))] : t;
}
function Wt(e, t) {
  return e ? re(/* @__PURE__ */ Object.create(null), e, t) : t;
}
function rs(e, t) {
  return e ? $(e) && $(t) ? [.../* @__PURE__ */ new Set([...e, ...t])] : re(
    /* @__PURE__ */ Object.create(null),
    ns(e),
    ns(t ?? {})
  ) : t;
}
function Ml(e, t) {
  if (!e)
    return t;
  if (!t)
    return e;
  const n = re(/* @__PURE__ */ Object.create(null), e);
  for (const o in t)
    n[o] = ge(e[o], t[o]);
  return n;
}
function Cr() {
  return {
    app: null,
    config: {
      isNativeTag: Zr,
      performance: !1,
      globalProperties: {},
      optionMergeStrategies: {},
      errorHandler: void 0,
      warnHandler: void 0,
      compilerOptions: {}
    },
    mixins: [],
    components: {},
    directives: {},
    provides: /* @__PURE__ */ Object.create(null),
    optionsCache: /* @__PURE__ */ new WeakMap(),
    propsCache: /* @__PURE__ */ new WeakMap(),
    emitsCache: /* @__PURE__ */ new WeakMap()
  };
}
let Ol = 0;
function Ll(e, t) {
  return function(o, s = null) {
    W(o) || (o = re({}, o)), s != null && !Z(s) && (s = null);
    const r = Cr(), i = /* @__PURE__ */ new Set();
    let l = !1;
    const a = r.app = {
      _uid: Ol++,
      _component: o,
      _props: s,
      _container: null,
      _context: r,
      _instance: null,
      version: ra,
      get config() {
        return r.config;
      },
      set config(u) {
      },
      use(u, ...f) {
        return i.has(u) || (u && W(u.install) ? (i.add(u), u.install(a, ...f)) : W(u) && (i.add(u), u(a, ...f))), a;
      },
      mixin(u) {
        return r.mixins.includes(u) || r.mixins.push(u), a;
      },
      component(u, f) {
        return f ? (r.components[u] = f, a) : r.components[u];
      },
      directive(u, f) {
        return f ? (r.directives[u] = f, a) : r.directives[u];
      },
      mount(u, f, h) {
        if (!l) {
          const p = te(
            o,
            s
          );
          return p.appContext = r, f && t ? t(p, u) : e(p, u, h), l = !0, a._container = u, u.__vue_app__ = a, Nn(p.component) || p.component.proxy;
        }
      },
      unmount() {
        l && (e(null, a._container), delete a._container.__vue_app__);
      },
      provide(u, f) {
        return r.provides[u] = f, a;
      },
      runWithContext(u) {
        xn = a;
        try {
          return u();
        } finally {
          xn = null;
        }
      }
    };
    return a;
  };
}
let xn = null;
function Tr(e, t) {
  if (ce) {
    let n = ce.provides;
    const o = ce.parent && ce.parent.provides;
    o === n && (n = ce.provides = Object.create(o)), n[e] = t;
  }
}
function jt(e, t, n = !1) {
  const o = ce || pe;
  if (o || xn) {
    const s = o ? o.parent == null ? o.vnode.appContext && o.vnode.appContext.provides : o.parent.provides : xn._context.provides;
    if (s && e in s)
      return s[e];
    if (arguments.length > 1)
      return n && W(t) ? t.call(o && o.proxy) : t;
  }
}
function Sl(e, t, n, o = !1) {
  const s = {}, r = {};
  mn(r, Dn, 1), e.propsDefaults = /* @__PURE__ */ Object.create(null), Er(e, t, s, r);
  for (const i in e.propsOptions[0])
    i in s || (s[i] = void 0);
  n ? e.props = o ? s : Yi(s) : e.type.props ? e.props = s : e.props = r, e.attrs = r;
}
function Pl(e, t, n, o) {
  const {
    props: s,
    attrs: r,
    vnode: { patchFlag: i }
  } = e, l = B(s), [a] = e.propsOptions;
  let u = !1;
  if (
    // always force full diff in dev
    // - #1942 if hmr is enabled with sfc component
    // - vite#872 non-sfc component used by sfc component
    (o || i > 0) && !(i & 16)
  ) {
    if (i & 8) {
      const f = e.vnode.dynamicProps;
      for (let h = 0; h < f.length; h++) {
        let p = f[h];
        if (Pn(e.emitsOptions, p))
          continue;
        const w = t[p];
        if (a)
          if (X(r, p))
            w !== r[p] && (r[p] = w, u = !0);
          else {
            const v = Ne(p);
            s[v] = ao(
              a,
              l,
              v,
              w,
              e,
              !1
              /* isAbsent */
            );
          }
        else
          w !== r[p] && (r[p] = w, u = !0);
      }
    }
  } else {
    Er(e, t, s, r) && (u = !0);
    let f;
    for (const h in l)
      (!t || // for camelCase
      !X(t, h) && // it's possible the original props was passed in as kebab-case
      // and converted to camelCase (#955)
      ((f = bt(h)) === h || !X(t, f))) && (a ? n && // for camelCase
      (n[h] !== void 0 || // for kebab-case
      n[f] !== void 0) && (s[h] = ao(
        a,
        l,
        h,
        void 0,
        e,
        !0
        /* isAbsent */
      )) : delete s[h]);
    if (r !== l)
      for (const h in r)
        (!t || !X(t, h)) && (delete r[h], u = !0);
  }
  u && je(e, "set", "$attrs");
}
function Er(e, t, n, o) {
  const [s, r] = e.propsOptions;
  let i = !1, l;
  if (t)
    for (let a in t) {
      if (pn(a))
        continue;
      const u = t[a];
      let f;
      s && X(s, f = Ne(a)) ? !r || !r.includes(f) ? n[f] = u : (l || (l = {}))[f] = u : Pn(e.emitsOptions, a) || (!(a in o) || u !== o[a]) && (o[a] = u, i = !0);
    }
  if (r) {
    const a = B(n), u = l || J;
    for (let f = 0; f < r.length; f++) {
      const h = r[f];
      n[h] = ao(
        s,
        a,
        h,
        u[h],
        e,
        !X(u, h)
      );
    }
  }
  return i;
}
function ao(e, t, n, o, s, r) {
  const i = e[n];
  if (i != null) {
    const l = X(i, "default");
    if (l && o === void 0) {
      const a = i.default;
      if (i.type !== Function && !i.skipFactory && W(a)) {
        const { propsDefaults: u } = s;
        n in u ? o = u[n] : (Ot(s), o = u[n] = a.call(
          null,
          t
        ), mt());
      } else
        o = a;
    }
    i[
      0
      /* shouldCast */
    ] && (r && !l ? o = !1 : i[
      1
      /* shouldCastTrue */
    ] && (o === "" || o === bt(n)) && (o = !0));
  }
  return o;
}
function Ar(e, t, n = !1) {
  const o = t.propsCache, s = o.get(e);
  if (s)
    return s;
  const r = e.props, i = {}, l = [];
  let a = !1;
  if (!W(e)) {
    const f = (h) => {
      a = !0;
      const [p, w] = Ar(h, t, !0);
      re(i, p), w && l.push(...w);
    };
    !n && t.mixins.length && t.mixins.forEach(f), e.extends && f(e.extends), e.mixins && e.mixins.forEach(f);
  }
  if (!r && !a)
    return Z(e) && o.set(e, kt), kt;
  if ($(r))
    for (let f = 0; f < r.length; f++) {
      const h = Ne(r[f]);
      is(h) && (i[h] = J);
    }
  else if (r)
    for (const f in r) {
      const h = Ne(f);
      if (is(h)) {
        const p = r[f], w = i[h] = $(p) || W(p) ? { type: p } : re({}, p);
        if (w) {
          const v = cs(Boolean, w.type), y = cs(String, w.type);
          w[
            0
            /* shouldCast */
          ] = v > -1, w[
            1
            /* shouldCastTrue */
          ] = y < 0 || v < y, (v > -1 || X(w, "default")) && l.push(h);
        }
      }
    }
  const u = [i, l];
  return Z(e) && o.set(e, u), u;
}
function is(e) {
  return e[0] !== "$";
}
function ls(e) {
  const t = e && e.toString().match(/^\s*(function|class) (\w+)/);
  return t ? t[2] : e === null ? "null" : "";
}
function as(e, t) {
  return ls(e) === ls(t);
}
function cs(e, t) {
  return $(t) ? t.findIndex((n) => as(n, e)) : W(t) && as(t, e) ? 0 : -1;
}
const Mr = (e) => e[0] === "_" || e === "$stable", Io = (e) => $(e) ? e.map(He) : [He(e)], Il = (e, t, n) => {
  if (t._n)
    return t;
  const o = fe((...s) => Io(t(...s)), n);
  return o._c = !1, o;
}, Or = (e, t, n) => {
  const o = e._ctx;
  for (const s in e) {
    if (Mr(s))
      continue;
    const r = e[s];
    if (W(r))
      t[s] = Il(s, r, o);
    else if (r != null) {
      const i = Io(r);
      t[s] = () => i;
    }
  }
}, Lr = (e, t) => {
  const n = Io(t);
  e.slots.default = () => n;
}, Rl = (e, t) => {
  if (e.vnode.shapeFlag & 32) {
    const n = t._;
    n ? (e.slots = B(t), mn(t, "_", n)) : Or(
      t,
      e.slots = {}
    );
  } else
    e.slots = {}, t && Lr(e, t);
  mn(e.slots, Dn, 1);
}, Hl = (e, t, n) => {
  const { vnode: o, slots: s } = e;
  let r = !0, i = J;
  if (o.shapeFlag & 32) {
    const l = t._;
    l ? n && l === 1 ? r = !1 : (re(s, t), !n && l === 1 && delete s._) : (r = !t.$stable, Or(t, s)), i = t;
  } else
    t && (Lr(e, t), i = { default: 1 });
  if (r)
    for (const l in s)
      !Mr(l) && !(l in i) && delete s[l];
};
function co(e, t, n, o, s = !1) {
  if ($(e)) {
    e.forEach(
      (p, w) => co(
        p,
        t && ($(t) ? t[w] : t),
        n,
        o,
        s
      )
    );
    return;
  }
  if (Bt(o) && !s)
    return;
  const r = o.shapeFlag & 4 ? Nn(o.component) || o.component.proxy : o.el, i = s ? null : r, { i: l, r: a } = e, u = t && t.r, f = l.refs === J ? l.refs = {} : l.refs, h = l.setupState;
  if (u != null && u !== a && (ie(u) ? (f[u] = null, X(h, u) && (h[u] = null)) : de(u) && (u.value = null)), W(a))
    Ge(a, l, 12, [i, f]);
  else {
    const p = ie(a), w = de(a);
    if (p || w) {
      const v = () => {
        if (e.f) {
          const y = p ? X(h, a) ? h[a] : f[a] : a.value;
          s ? $(y) && bo(y, r) : $(y) ? y.includes(r) || y.push(r) : p ? (f[a] = [r], X(h, a) && (h[a] = f[a])) : (a.value = [r], e.k && (f[e.k] = a.value));
        } else
          p ? (f[a] = i, X(h, a) && (h[a] = i)) : w && (a.value = i, e.k && (f[e.k] = i));
      };
      i ? (v.id = -1, _e(v, n)) : v();
    }
  }
}
const _e = ll;
function $l(e) {
  return Dl(e);
}
function Dl(e, t) {
  const n = Zn();
  n.__VUE__ = !0;
  const {
    insert: o,
    remove: s,
    patchProp: r,
    createElement: i,
    createText: l,
    createComment: a,
    setText: u,
    setElementText: f,
    parentNode: h,
    nextSibling: p,
    setScopeId: w = Se,
    insertStaticContent: v
  } = e, y = (c, d, g, b = null, m = null, k = null, A = !1, x = null, C = !!d.dynamicChildren) => {
    if (c === d)
      return;
    c && !ut(c, d) && (b = tn(c), Pe(c, m, k, !0), c = null), d.patchFlag === -2 && (C = !1, d.dynamicChildren = null);
    const { type: _, ref: P, shapeFlag: L } = d;
    switch (_) {
      case $n:
        R(c, d, g, b);
        break;
      case Ee:
        T(c, d, g, b);
        break;
      case qn:
        c == null && E(d, g, b, A);
        break;
      case Ce:
        S(
          c,
          d,
          g,
          b,
          m,
          k,
          A,
          x,
          C
        );
        break;
      default:
        L & 1 ? V(
          c,
          d,
          g,
          b,
          m,
          k,
          A,
          x,
          C
        ) : L & 6 ? Q(
          c,
          d,
          g,
          b,
          m,
          k,
          A,
          x,
          C
        ) : (L & 64 || L & 128) && _.process(
          c,
          d,
          g,
          b,
          m,
          k,
          A,
          x,
          C,
          _t
        );
    }
    P != null && m && co(P, c && c.ref, k, d || c, !d);
  }, R = (c, d, g, b) => {
    if (c == null)
      o(
        d.el = l(d.children),
        g,
        b
      );
    else {
      const m = d.el = c.el;
      d.children !== c.children && u(m, d.children);
    }
  }, T = (c, d, g, b) => {
    c == null ? o(
      d.el = a(d.children || ""),
      g,
      b
    ) : d.el = c.el;
  }, E = (c, d, g, b) => {
    [c.el, c.anchor] = v(
      c.children,
      d,
      g,
      b,
      c.el,
      c.anchor
    );
  }, H = ({ el: c, anchor: d }, g, b) => {
    let m;
    for (; c && c !== d; )
      m = p(c), o(c, g, b), c = m;
    o(d, g, b);
  }, O = ({ el: c, anchor: d }) => {
    let g;
    for (; c && c !== d; )
      g = p(c), s(c), c = g;
    s(d);
  }, V = (c, d, g, b, m, k, A, x, C) => {
    A = A || d.type === "svg", c == null ? ue(
      d,
      g,
      b,
      m,
      k,
      A,
      x,
      C
    ) : z(
      c,
      d,
      m,
      k,
      A,
      x,
      C
    );
  }, ue = (c, d, g, b, m, k, A, x) => {
    let C, _;
    const { type: P, props: L, shapeFlag: I, transition: N, dirs: Y } = c;
    if (C = c.el = i(
      c.type,
      k,
      L && L.is,
      L
    ), I & 8 ? f(C, c.children) : I & 16 && D(
      c.children,
      C,
      null,
      b,
      m,
      k && P !== "foreignObject",
      A,
      x
    ), Y && rt(c, null, b, "created"), le(C, c, c.scopeId, A, b), L) {
      for (const q in L)
        q !== "value" && !pn(q) && r(
          C,
          q,
          null,
          L[q],
          k,
          c.children,
          b,
          m,
          Fe
        );
      "value" in L && r(C, "value", null, L.value), (_ = L.onVnodeBeforeMount) && Re(_, b, c);
    }
    Y && rt(c, null, b, "beforeMount");
    const U = (!m || m && !m.pendingBranch) && N && !N.persisted;
    U && N.beforeEnter(C), o(C, d, g), ((_ = L && L.onVnodeMounted) || U || Y) && _e(() => {
      _ && Re(_, b, c), U && N.enter(C), Y && rt(c, null, b, "mounted");
    }, m);
  }, le = (c, d, g, b, m) => {
    if (g && w(c, g), b)
      for (let k = 0; k < b.length; k++)
        w(c, b[k]);
    if (m) {
      let k = m.subTree;
      if (d === k) {
        const A = m.vnode;
        le(
          c,
          A,
          A.scopeId,
          A.slotScopeIds,
          m.parent
        );
      }
    }
  }, D = (c, d, g, b, m, k, A, x, C = 0) => {
    for (let _ = C; _ < c.length; _++) {
      const P = c[_] = x ? Je(c[_]) : He(c[_]);
      y(
        null,
        P,
        d,
        g,
        b,
        m,
        k,
        A,
        x
      );
    }
  }, z = (c, d, g, b, m, k, A) => {
    const x = d.el = c.el;
    let { patchFlag: C, dynamicChildren: _, dirs: P } = d;
    C |= c.patchFlag & 16;
    const L = c.props || J, I = d.props || J;
    let N;
    g && it(g, !1), (N = I.onVnodeBeforeUpdate) && Re(N, g, d, c), P && rt(d, c, g, "beforeUpdate"), g && it(g, !0);
    const Y = m && d.type !== "foreignObject";
    if (_ ? j(
      c.dynamicChildren,
      _,
      x,
      g,
      b,
      Y,
      k
    ) : A || K(
      c,
      d,
      x,
      null,
      g,
      b,
      Y,
      k,
      !1
    ), C > 0) {
      if (C & 16)
        ne(
          x,
          d,
          L,
          I,
          g,
          b,
          m
        );
      else if (C & 2 && L.class !== I.class && r(x, "class", null, I.class, m), C & 4 && r(x, "style", L.style, I.style, m), C & 8) {
        const U = d.dynamicProps;
        for (let q = 0; q < U.length; q++) {
          const oe = U[q], Ae = L[oe], vt = I[oe];
          (vt !== Ae || oe === "value") && r(
            x,
            oe,
            Ae,
            vt,
            m,
            c.children,
            g,
            b,
            Fe
          );
        }
      }
      C & 1 && c.children !== d.children && f(x, d.children);
    } else
      !A && _ == null && ne(
        x,
        d,
        L,
        I,
        g,
        b,
        m
      );
    ((N = I.onVnodeUpdated) || P) && _e(() => {
      N && Re(N, g, d, c), P && rt(d, c, g, "updated");
    }, b);
  }, j = (c, d, g, b, m, k, A) => {
    for (let x = 0; x < d.length; x++) {
      const C = c[x], _ = d[x], P = (
        // oldVNode may be an errored async setup() component inside Suspense
        // which will not have a mounted element
        C.el && // - In the case of a Fragment, we need to provide the actual parent
        // of the Fragment itself so it can move its children.
        (C.type === Ce || // - In the case of different nodes, there is going to be a replacement
        // which also requires the correct parent container
        !ut(C, _) || // - In the case of a component, it could contain anything.
        C.shapeFlag & 70) ? h(C.el) : (
          // In other cases, the parent container is not actually used so we
          // just pass the block element here to avoid a DOM parentNode call.
          g
        )
      );
      y(
        C,
        _,
        P,
        null,
        b,
        m,
        k,
        A,
        !0
      );
    }
  }, ne = (c, d, g, b, m, k, A) => {
    if (g !== b) {
      if (g !== J)
        for (const x in g)
          !pn(x) && !(x in b) && r(
            c,
            x,
            g[x],
            null,
            A,
            d.children,
            m,
            k,
            Fe
          );
      for (const x in b) {
        if (pn(x))
          continue;
        const C = b[x], _ = g[x];
        C !== _ && x !== "value" && r(
          c,
          x,
          _,
          C,
          A,
          d.children,
          m,
          k,
          Fe
        );
      }
      "value" in b && r(c, "value", g.value, b.value);
    }
  }, S = (c, d, g, b, m, k, A, x, C) => {
    const _ = d.el = c ? c.el : l(""), P = d.anchor = c ? c.anchor : l("");
    let { patchFlag: L, dynamicChildren: I, slotScopeIds: N } = d;
    N && (x = x ? x.concat(N) : N), c == null ? (o(_, g, b), o(P, g, b), D(
      d.children,
      g,
      P,
      m,
      k,
      A,
      x,
      C
    )) : L > 0 && L & 64 && I && // #2715 the previous fragment could've been a BAILed one as a result
    // of renderSlot() with no valid children
    c.dynamicChildren ? (j(
      c.dynamicChildren,
      I,
      g,
      m,
      k,
      A,
      x
    ), // #2080 if the stable fragment has a key, it's a <template v-for> that may
    //  get moved around. Make sure all root level vnodes inherit el.
    // #2134 or if it's a component root, it may also get moved around
    // as the component is being moved.
    (d.key != null || m && d === m.subTree) && Ro(
      c,
      d,
      !0
      /* shallow */
    )) : K(
      c,
      d,
      g,
      P,
      m,
      k,
      A,
      x,
      C
    );
  }, Q = (c, d, g, b, m, k, A, x, C) => {
    d.slotScopeIds = x, c == null ? d.shapeFlag & 512 ? m.ctx.activate(
      d,
      g,
      b,
      A,
      C
    ) : we(
      d,
      g,
      b,
      m,
      k,
      A,
      C
    ) : Rt(c, d, C);
  }, we = (c, d, g, b, m, k, A) => {
    const x = c.component = Ul(
      c,
      b,
      m
    );
    if (In(c) && (x.ctx.renderer = _t), Jl(x), x.asyncDep) {
      if (m && m.registerDep(x, ae), !c.el) {
        const C = x.subTree = te(Ee);
        T(null, C, d, g);
      }
      return;
    }
    ae(
      x,
      c,
      d,
      g,
      m,
      k,
      A
    );
  }, Rt = (c, d, g) => {
    const b = d.component = c.component;
    if (sl(c, d, g))
      if (b.asyncDep && !b.asyncResolved) {
        ee(b, d, g);
        return;
      } else
        b.next = d, Qi(b.update), b.update();
    else
      d.el = c.el, b.vnode = d;
  }, ae = (c, d, g, b, m, k, A) => {
    const x = () => {
      if (c.isMounted) {
        let { next: P, bu: L, u: I, parent: N, vnode: Y } = c, U = P, q;
        it(c, !1), P ? (P.el = Y.el, ee(c, P, A)) : P = Y, L && Bn(L), (q = P.props && P.props.onVnodeBeforeUpdate) && Re(q, N, P, Y), it(c, !0);
        const oe = Xn(c), Ae = c.subTree;
        c.subTree = oe, y(
          Ae,
          oe,
          // parent may have changed if it's in a teleport
          h(Ae.el),
          // anchor may have changed if it's in a fragment
          tn(Ae),
          c,
          m,
          k
        ), P.el = oe.el, U === null && rl(c, oe.el), I && _e(I, m), (q = P.props && P.props.onVnodeUpdated) && _e(
          () => Re(q, N, P, Y),
          m
        );
      } else {
        let P;
        const { el: L, props: I } = d, { bm: N, m: Y, parent: U } = c, q = Bt(d);
        if (it(c, !1), N && Bn(N), !q && (P = I && I.onVnodeBeforeMount) && Re(P, U, d), it(c, !0), L && Wn) {
          const oe = () => {
            c.subTree = Xn(c), Wn(
              L,
              c.subTree,
              c,
              m,
              null
            );
          };
          q ? d.type.__asyncLoader().then(
            // note: we are moving the render call into an async callback,
            // which means it won't track dependencies - but it's ok because
            // a server-rendered async wrapper is already in resolved state
            // and it will never need to change.
            () => !c.isUnmounted && oe()
          ) : oe();
        } else {
          const oe = c.subTree = Xn(c);
          y(
            null,
            oe,
            g,
            b,
            c,
            m,
            k
          ), d.el = oe.el;
        }
        if (Y && _e(Y, m), !q && (P = I && I.onVnodeMounted)) {
          const oe = d;
          _e(
            () => Re(P, U, oe),
            m
          );
        }
        (d.shapeFlag & 256 || U && Bt(U.vnode) && U.vnode.shapeFlag & 256) && c.a && _e(c.a, m), c.isMounted = !0, d = g = b = null;
      }
    }, C = c.effect = new xo(
      x,
      () => Oo(_),
      c.scope
      // track it in component's effect scope
    ), _ = c.update = () => C.run();
    _.id = c.uid, it(c, !0), _();
  }, ee = (c, d, g) => {
    d.component = c;
    const b = c.vnode.props;
    c.vnode = d, c.next = null, Pl(c, d.props, b, g), Hl(c, d.children, g), St(), Qo(), Pt();
  }, K = (c, d, g, b, m, k, A, x, C = !1) => {
    const _ = c && c.children, P = c ? c.shapeFlag : 0, L = d.children, { patchFlag: I, shapeFlag: N } = d;
    if (I > 0) {
      if (I & 128) {
        en(
          _,
          L,
          g,
          b,
          m,
          k,
          A,
          x,
          C
        );
        return;
      } else if (I & 256) {
        ot(
          _,
          L,
          g,
          b,
          m,
          k,
          A,
          x,
          C
        );
        return;
      }
    }
    N & 8 ? (P & 16 && Fe(_, m, k), L !== _ && f(g, L)) : P & 16 ? N & 16 ? en(
      _,
      L,
      g,
      b,
      m,
      k,
      A,
      x,
      C
    ) : Fe(_, m, k, !0) : (P & 8 && f(g, ""), N & 16 && D(
      L,
      g,
      b,
      m,
      k,
      A,
      x,
      C
    ));
  }, ot = (c, d, g, b, m, k, A, x, C) => {
    c = c || kt, d = d || kt;
    const _ = c.length, P = d.length, L = Math.min(_, P);
    let I;
    for (I = 0; I < L; I++) {
      const N = d[I] = C ? Je(d[I]) : He(d[I]);
      y(
        c[I],
        N,
        g,
        null,
        m,
        k,
        A,
        x,
        C
      );
    }
    _ > P ? Fe(
      c,
      m,
      k,
      !0,
      !1,
      L
    ) : D(
      d,
      g,
      b,
      m,
      k,
      A,
      x,
      C,
      L
    );
  }, en = (c, d, g, b, m, k, A, x, C) => {
    let _ = 0;
    const P = d.length;
    let L = c.length - 1, I = P - 1;
    for (; _ <= L && _ <= I; ) {
      const N = c[_], Y = d[_] = C ? Je(d[_]) : He(d[_]);
      if (ut(N, Y))
        y(
          N,
          Y,
          g,
          null,
          m,
          k,
          A,
          x,
          C
        );
      else
        break;
      _++;
    }
    for (; _ <= L && _ <= I; ) {
      const N = c[L], Y = d[I] = C ? Je(d[I]) : He(d[I]);
      if (ut(N, Y))
        y(
          N,
          Y,
          g,
          null,
          m,
          k,
          A,
          x,
          C
        );
      else
        break;
      L--, I--;
    }
    if (_ > L) {
      if (_ <= I) {
        const N = I + 1, Y = N < P ? d[N].el : b;
        for (; _ <= I; )
          y(
            null,
            d[_] = C ? Je(d[_]) : He(d[_]),
            g,
            Y,
            m,
            k,
            A,
            x,
            C
          ), _++;
      }
    } else if (_ > I)
      for (; _ <= L; )
        Pe(c[_], m, k, !0), _++;
    else {
      const N = _, Y = _, U = /* @__PURE__ */ new Map();
      for (_ = Y; _ <= I; _++) {
        const xe = d[_] = C ? Je(d[_]) : He(d[_]);
        xe.key != null && U.set(xe.key, _);
      }
      let q, oe = 0;
      const Ae = I - Y + 1;
      let vt = !1, Yo = 0;
      const Ht = new Array(Ae);
      for (_ = 0; _ < Ae; _++)
        Ht[_] = 0;
      for (_ = N; _ <= L; _++) {
        const xe = c[_];
        if (oe >= Ae) {
          Pe(xe, m, k, !0);
          continue;
        }
        let Ie;
        if (xe.key != null)
          Ie = U.get(xe.key);
        else
          for (q = Y; q <= I; q++)
            if (Ht[q - Y] === 0 && ut(xe, d[q])) {
              Ie = q;
              break;
            }
        Ie === void 0 ? Pe(xe, m, k, !0) : (Ht[Ie - Y] = _ + 1, Ie >= Yo ? Yo = Ie : vt = !0, y(
          xe,
          d[Ie],
          g,
          null,
          m,
          k,
          A,
          x,
          C
        ), oe++);
      }
      const Bo = vt ? Nl(Ht) : kt;
      for (q = Bo.length - 1, _ = Ae - 1; _ >= 0; _--) {
        const xe = Y + _, Ie = d[xe], Xo = xe + 1 < P ? d[xe + 1].el : b;
        Ht[_] === 0 ? y(
          null,
          Ie,
          g,
          Xo,
          m,
          k,
          A,
          x,
          C
        ) : vt && (q < 0 || _ !== Bo[q] ? st(Ie, g, Xo, 2) : q--);
      }
    }
  }, st = (c, d, g, b, m = null) => {
    const { el: k, type: A, transition: x, children: C, shapeFlag: _ } = c;
    if (_ & 6) {
      st(c.component.subTree, d, g, b);
      return;
    }
    if (_ & 128) {
      c.suspense.move(d, g, b);
      return;
    }
    if (_ & 64) {
      A.move(c, d, g, _t);
      return;
    }
    if (A === Ce) {
      o(k, d, g);
      for (let L = 0; L < C.length; L++)
        st(C[L], d, g, b);
      o(c.anchor, d, g);
      return;
    }
    if (A === qn) {
      H(c, d, g);
      return;
    }
    if (b !== 2 && _ & 1 && x)
      if (b === 0)
        x.beforeEnter(k), o(k, d, g), _e(() => x.enter(k), m);
      else {
        const { leave: L, delayLeave: I, afterLeave: N } = x, Y = () => o(k, d, g), U = () => {
          L(k, () => {
            Y(), N && N();
          });
        };
        I ? I(k, Y, U) : U();
      }
    else
      o(k, d, g);
  }, Pe = (c, d, g, b = !1, m = !1) => {
    const {
      type: k,
      props: A,
      ref: x,
      children: C,
      dynamicChildren: _,
      shapeFlag: P,
      patchFlag: L,
      dirs: I
    } = c;
    if (x != null && co(x, null, g, c, !0), P & 256) {
      d.ctx.deactivate(c);
      return;
    }
    const N = P & 1 && I, Y = !Bt(c);
    let U;
    if (Y && (U = A && A.onVnodeBeforeUnmount) && Re(U, d, c), P & 6)
      Kr(c.component, g, b);
    else {
      if (P & 128) {
        c.suspense.unmount(g, b);
        return;
      }
      N && rt(c, null, d, "beforeUnmount"), P & 64 ? c.type.remove(
        c,
        d,
        g,
        m,
        _t,
        b
      ) : _ && // #1153: fast path should not be taken for non-stable (v-for) fragments
      (k !== Ce || L > 0 && L & 64) ? Fe(
        _,
        d,
        g,
        !1,
        !0
      ) : (k === Ce && L & 384 || !m && P & 16) && Fe(C, d, g), b && Fo(c);
    }
    (Y && (U = A && A.onVnodeUnmounted) || N) && _e(() => {
      U && Re(U, d, c), N && rt(c, null, d, "unmounted");
    }, g);
  }, Fo = (c) => {
    const { type: d, el: g, anchor: b, transition: m } = c;
    if (d === Ce) {
      qr(g, b);
      return;
    }
    if (d === qn) {
      O(c);
      return;
    }
    const k = () => {
      s(g), m && !m.persisted && m.afterLeave && m.afterLeave();
    };
    if (c.shapeFlag & 1 && m && !m.persisted) {
      const { leave: A, delayLeave: x } = m, C = () => A(g, k);
      x ? x(c.el, k, C) : C();
    } else
      k();
  }, qr = (c, d) => {
    let g;
    for (; c !== d; )
      g = p(c), s(c), c = g;
    s(d);
  }, Kr = (c, d, g) => {
    const { bum: b, scope: m, update: k, subTree: A, um: x } = c;
    b && Bn(b), m.stop(), k && (k.active = !1, Pe(A, c, d, g)), x && _e(x, d), _e(() => {
      c.isUnmounted = !0;
    }, d), d && d.pendingBranch && !d.isUnmounted && c.asyncDep && !c.asyncResolved && c.suspenseId === d.pendingId && (d.deps--, d.deps === 0 && d.resolve());
  }, Fe = (c, d, g, b = !1, m = !1, k = 0) => {
    for (let A = k; A < c.length; A++)
      Pe(c[A], d, g, b, m);
  }, tn = (c) => c.shapeFlag & 6 ? tn(c.component.subTree) : c.shapeFlag & 128 ? c.suspense.next() : p(c.anchor || c.el), Wo = (c, d, g) => {
    c == null ? d._vnode && Pe(d._vnode, null, null, !0) : y(d._vnode || null, c, d, null, null, null, g), Qo(), cr(), d._vnode = c;
  }, _t = {
    p: y,
    um: Pe,
    m: st,
    r: Fo,
    mt: we,
    mc: D,
    pc: K,
    pbc: j,
    n: tn,
    o: e
  };
  let Fn, Wn;
  return t && ([Fn, Wn] = t(
    _t
  )), {
    render: Wo,
    hydrate: Fn,
    createApp: Ll(Wo, Fn)
  };
}
function it({ effect: e, update: t }, n) {
  e.allowRecurse = t.allowRecurse = n;
}
function Ro(e, t, n = !1) {
  const o = e.children, s = t.children;
  if ($(o) && $(s))
    for (let r = 0; r < o.length; r++) {
      const i = o[r];
      let l = s[r];
      l.shapeFlag & 1 && !l.dynamicChildren && ((l.patchFlag <= 0 || l.patchFlag === 32) && (l = s[r] = Je(s[r]), l.el = i.el), n || Ro(i, l)), l.type === $n && (l.el = i.el);
    }
}
function Nl(e) {
  const t = e.slice(), n = [0];
  let o, s, r, i, l;
  const a = e.length;
  for (o = 0; o < a; o++) {
    const u = e[o];
    if (u !== 0) {
      if (s = n[n.length - 1], e[s] < u) {
        t[o] = s, n.push(o);
        continue;
      }
      for (r = 0, i = n.length - 1; r < i; )
        l = r + i >> 1, e[n[l]] < u ? r = l + 1 : i = l;
      u < e[n[r]] && (r > 0 && (t[o] = n[r - 1]), n[r] = o);
    }
  }
  for (r = n.length, i = n[r - 1]; r-- > 0; )
    n[r] = i, i = t[i];
  return n;
}
const Fl = (e) => e.__isTeleport, zt = (e) => e && (e.disabled || e.disabled === ""), us = (e) => typeof SVGElement < "u" && e instanceof SVGElement, uo = (e, t) => {
  const n = e && e.to;
  return ie(n) ? t ? t(n) : null : n;
}, Wl = {
  __isTeleport: !0,
  process(e, t, n, o, s, r, i, l, a, u) {
    const {
      mc: f,
      pc: h,
      pbc: p,
      o: { insert: w, querySelector: v, createText: y, createComment: R }
    } = u, T = zt(t.props);
    let { shapeFlag: E, children: H, dynamicChildren: O } = t;
    if (e == null) {
      const V = t.el = y(""), ue = t.anchor = y("");
      w(V, n, o), w(ue, n, o);
      const le = t.target = uo(t.props, v), D = t.targetAnchor = y("");
      le && (w(D, le), i = i || us(le));
      const z = (j, ne) => {
        E & 16 && f(
          H,
          j,
          ne,
          s,
          r,
          i,
          l,
          a
        );
      };
      T ? z(n, ue) : le && z(le, D);
    } else {
      t.el = e.el;
      const V = t.anchor = e.anchor, ue = t.target = e.target, le = t.targetAnchor = e.targetAnchor, D = zt(e.props), z = D ? n : ue, j = D ? V : le;
      if (i = i || us(ue), O ? (p(
        e.dynamicChildren,
        O,
        z,
        s,
        r,
        i,
        l
      ), Ro(e, t, !0)) : a || h(
        e,
        t,
        z,
        j,
        s,
        r,
        i,
        l,
        !1
      ), T)
        D || un(
          t,
          n,
          V,
          u,
          1
        );
      else if ((t.props && t.props.to) !== (e.props && e.props.to)) {
        const ne = t.target = uo(
          t.props,
          v
        );
        ne && un(
          t,
          ne,
          null,
          u,
          0
        );
      } else
        D && un(
          t,
          ue,
          le,
          u,
          1
        );
    }
    Sr(t);
  },
  remove(e, t, n, o, { um: s, o: { remove: r } }, i) {
    const { shapeFlag: l, children: a, anchor: u, targetAnchor: f, target: h, props: p } = e;
    if (h && r(f), (i || !zt(p)) && (r(u), l & 16))
      for (let w = 0; w < a.length; w++) {
        const v = a[w];
        s(
          v,
          t,
          n,
          !0,
          !!v.dynamicChildren
        );
      }
  },
  move: un,
  hydrate: Yl
};
function un(e, t, n, { o: { insert: o }, m: s }, r = 2) {
  r === 0 && o(e.targetAnchor, t, n);
  const { el: i, anchor: l, shapeFlag: a, children: u, props: f } = e, h = r === 2;
  if (h && o(i, t, n), (!h || zt(f)) && a & 16)
    for (let p = 0; p < u.length; p++)
      s(
        u[p],
        t,
        n,
        2
      );
  h && o(l, t, n);
}
function Yl(e, t, n, o, s, r, {
  o: { nextSibling: i, parentNode: l, querySelector: a }
}, u) {
  const f = t.target = uo(
    t.props,
    a
  );
  if (f) {
    const h = f._lpa || f.firstChild;
    if (t.shapeFlag & 16)
      if (zt(t.props))
        t.anchor = u(
          i(e),
          t,
          l(e),
          n,
          o,
          s,
          r
        ), t.targetAnchor = h;
      else {
        t.anchor = i(e);
        let p = h;
        for (; p; )
          if (p = i(p), p && p.nodeType === 8 && p.data === "teleport anchor") {
            t.targetAnchor = p, f._lpa = t.targetAnchor && i(t.targetAnchor);
            break;
          }
        u(
          h,
          t,
          f,
          n,
          o,
          s,
          r
        );
      }
    Sr(t);
  }
  return t.anchor && i(t.anchor);
}
const Bl = Wl;
function Sr(e) {
  const t = e.ctx;
  if (t && t.ut) {
    let n = e.children[0].el;
    for (; n !== e.targetAnchor; )
      n.nodeType === 1 && n.setAttribute("data-v-owner", t.uid), n = n.nextSibling;
    t.ut();
  }
}
const Ce = Symbol.for("v-fgt"), $n = Symbol.for("v-txt"), Ee = Symbol.for("v-cmt"), qn = Symbol.for("v-stc"), qt = [];
let Le = null;
function be(e = !1) {
  qt.push(Le = e ? null : []);
}
function Xl() {
  qt.pop(), Le = qt[qt.length - 1] || null;
}
let Zt = 1;
function fs(e) {
  Zt += e;
}
function Pr(e) {
  return e.dynamicChildren = Zt > 0 ? Le || kt : null, Xl(), Zt > 0 && Le && Le.push(e), e;
}
function et(e, t, n, o, s, r) {
  return Pr(
    M(
      e,
      t,
      n,
      o,
      s,
      r,
      !0
      /* isBlock */
    )
  );
}
function gt(e, t, n, o, s) {
  return Pr(
    te(
      e,
      t,
      n,
      o,
      s,
      !0
      /* isBlock: prevent a block from tracking itself */
    )
  );
}
function kn(e) {
  return e ? e.__v_isVNode === !0 : !1;
}
function ut(e, t) {
  return e.type === t.type && e.key === t.key;
}
const Dn = "__vInternal", Ir = ({ key: e }) => e ?? null, gn = ({
  ref: e,
  ref_key: t,
  ref_for: n
}) => (typeof e == "number" && (e = "" + e), e != null ? ie(e) || de(e) || W(e) ? { i: pe, r: e, k: t, f: !!n } : e : null);
function M(e, t = null, n = null, o = 0, s = null, r = e === Ce ? 0 : 1, i = !1, l = !1) {
  const a = {
    __v_isVNode: !0,
    __v_skip: !0,
    type: e,
    props: t,
    key: t && Ir(t),
    ref: t && gn(t),
    scopeId: dr,
    slotScopeIds: null,
    children: n,
    component: null,
    suspense: null,
    ssContent: null,
    ssFallback: null,
    dirs: null,
    transition: null,
    el: null,
    anchor: null,
    target: null,
    targetAnchor: null,
    staticCount: 0,
    shapeFlag: r,
    patchFlag: o,
    dynamicProps: s,
    dynamicChildren: null,
    appContext: null,
    ctx: pe
  };
  return l ? (Ho(a, n), r & 128 && e.normalize(a)) : n && (a.shapeFlag |= ie(n) ? 8 : 16), Zt > 0 && // avoid a block node from tracking itself
  !i && // has current parent block
  Le && // presence of a patch flag indicates this node needs patching on updates.
  // component nodes also should always be patched, because even if the
  // component doesn't need to update, it needs to persist the instance on to
  // the next vnode so that it can be properly unmounted later.
  (a.patchFlag > 0 || r & 6) && // the EVENTS flag is only for hydration and if it is the only flag, the
  // vnode should not be considered dynamic due to handler caching.
  a.patchFlag !== 32 && Le.push(a), a;
}
const te = jl;
function jl(e, t = null, n = null, o = 0, s = null, r = !1) {
  if ((!e || e === wl) && (e = Ee), kn(e)) {
    const l = nt(
      e,
      t,
      !0
      /* mergeRef: true */
    );
    return n && Ho(l, n), Zt > 0 && !r && Le && (l.shapeFlag & 6 ? Le[Le.indexOf(e)] = l : Le.push(l)), l.patchFlag |= -2, l;
  }
  if (ta(e) && (e = e.__vccOpts), t) {
    t = zl(t);
    let { class: l, style: a } = t;
    l && !ie(l) && (t.class = pt(l)), Z(a) && (tr(a) && !$(a) && (a = re({}, a)), t.style = yo(a));
  }
  const i = ie(e) ? 1 : il(e) ? 128 : Fl(e) ? 64 : Z(e) ? 4 : W(e) ? 2 : 0;
  return M(
    e,
    t,
    n,
    o,
    s,
    i,
    r,
    !0
  );
}
function zl(e) {
  return e ? tr(e) || Dn in e ? re({}, e) : e : null;
}
function nt(e, t, n = !1) {
  const { props: o, ref: s, patchFlag: r, children: i } = e, l = t ? Rr(o || {}, t) : o;
  return {
    __v_isVNode: !0,
    __v_skip: !0,
    type: e.type,
    props: l,
    key: l && Ir(l),
    ref: t && t.ref ? (
      // #2078 in the case of <component :is="vnode" ref="extra"/>
      // if the vnode itself already has a ref, cloneVNode will need to merge
      // the refs so the single vnode can be set on multiple refs
      n && s ? $(s) ? s.concat(gn(t)) : [s, gn(t)] : gn(t)
    ) : s,
    scopeId: e.scopeId,
    slotScopeIds: e.slotScopeIds,
    children: i,
    target: e.target,
    targetAnchor: e.targetAnchor,
    staticCount: e.staticCount,
    shapeFlag: e.shapeFlag,
    // if the vnode is cloned with extra props, we can no longer assume its
    // existing patch flag to be reliable and need to add the FULL_PROPS flag.
    // note: preserve flag for fragments since they use the flag for children
    // fast paths only.
    patchFlag: t && e.type !== Ce ? r === -1 ? 16 : r | 16 : r,
    dynamicProps: e.dynamicProps,
    dynamicChildren: e.dynamicChildren,
    appContext: e.appContext,
    dirs: e.dirs,
    transition: e.transition,
    // These should technically only be non-null on mounted VNodes. However,
    // they *should* be copied for kept-alive vnodes. So we just always copy
    // them since them being non-null during a mount doesn't affect the logic as
    // they will simply be overwritten.
    component: e.component,
    suspense: e.suspense,
    ssContent: e.ssContent && nt(e.ssContent),
    ssFallback: e.ssFallback && nt(e.ssFallback),
    el: e.el,
    anchor: e.anchor,
    ctx: e.ctx,
    ce: e.ce
  };
}
function me(e = " ", t = 0) {
  return te($n, null, e, t);
}
function Yt(e = "", t = !1) {
  return t ? (be(), gt(Ee, null, e)) : te(Ee, null, e);
}
function He(e) {
  return e == null || typeof e == "boolean" ? te(Ee) : $(e) ? te(
    Ce,
    null,
    // #3666, avoid reference pollution when reusing vnode
    e.slice()
  ) : typeof e == "object" ? Je(e) : te($n, null, String(e));
}
function Je(e) {
  return e.el === null && e.patchFlag !== -1 || e.memo ? e : nt(e);
}
function Ho(e, t) {
  let n = 0;
  const { shapeFlag: o } = e;
  if (t == null)
    t = null;
  else if ($(t))
    n = 16;
  else if (typeof t == "object")
    if (o & 65) {
      const s = t.default;
      s && (s._c && (s._d = !1), Ho(e, s()), s._c && (s._d = !0));
      return;
    } else {
      n = 32;
      const s = t._;
      !s && !(Dn in t) ? t._ctx = pe : s === 3 && pe && (pe.slots._ === 1 ? t._ = 1 : (t._ = 2, e.patchFlag |= 1024));
    }
  else
    W(t) ? (t = { default: t, _ctx: pe }, n = 32) : (t = String(t), o & 64 ? (n = 16, t = [me(t)]) : n = 8);
  e.children = t, e.shapeFlag |= n;
}
function Rr(...e) {
  const t = {};
  for (let n = 0; n < e.length; n++) {
    const o = e[n];
    for (const s in o)
      if (s === "class")
        t.class !== o.class && (t.class = pt([t.class, o.class]));
      else if (s === "style")
        t.style = yo([t.style, o.style]);
      else if (Tn(s)) {
        const r = t[s], i = o[s];
        i && r !== i && !($(r) && r.includes(i)) && (t[s] = r ? [].concat(r, i) : i);
      } else
        s !== "" && (t[s] = o[s]);
  }
  return t;
}
function Re(e, t, n, o = null) {
  Te(e, t, 7, [
    n,
    o
  ]);
}
const ql = Cr();
let Kl = 0;
function Ul(e, t, n) {
  const o = e.type, s = (t ? t.appContext : e.appContext) || ql, r = {
    uid: Kl++,
    vnode: e,
    type: o,
    parent: t,
    appContext: s,
    root: null,
    // to be immediately set
    next: null,
    subTree: null,
    // will be set synchronously right after creation
    effect: null,
    update: null,
    // will be set synchronously right after creation
    scope: new fi(
      !0
      /* detached */
    ),
    render: null,
    proxy: null,
    exposed: null,
    exposeProxy: null,
    withProxy: null,
    provides: t ? t.provides : Object.create(s.provides),
    accessCache: null,
    renderCache: [],
    // local resolved assets
    components: null,
    directives: null,
    // resolved props and emits options
    propsOptions: Ar(o, s),
    emitsOptions: fr(o, s),
    // emit
    emit: null,
    // to be set immediately
    emitted: null,
    // props default value
    propsDefaults: J,
    // inheritAttrs
    inheritAttrs: o.inheritAttrs,
    // state
    ctx: J,
    data: J,
    props: J,
    attrs: J,
    slots: J,
    refs: J,
    setupState: J,
    setupContext: null,
    attrsProxy: null,
    slotsProxy: null,
    // suspense related
    suspense: n,
    suspenseId: n ? n.pendingId : 0,
    asyncDep: null,
    asyncResolved: !1,
    // lifecycle hooks
    // not using enums here because it results in computed properties
    isMounted: !1,
    isUnmounted: !1,
    isDeactivated: !1,
    bc: null,
    c: null,
    bm: null,
    m: null,
    bu: null,
    u: null,
    um: null,
    bum: null,
    da: null,
    a: null,
    rtg: null,
    rtc: null,
    ec: null,
    sp: null
  };
  return r.ctx = { _: r }, r.root = t ? t.root : r, r.emit = tl.bind(null, r), e.ce && e.ce(r), r;
}
let ce = null;
const Vl = () => ce || pe;
let $o, yt, ds = "__VUE_INSTANCE_SETTERS__";
(yt = Zn()[ds]) || (yt = Zn()[ds] = []), yt.push((e) => ce = e), $o = (e) => {
  yt.length > 1 ? yt.forEach((t) => t(e)) : yt[0](e);
};
const Ot = (e) => {
  $o(e), e.scope.on();
}, mt = () => {
  ce && ce.scope.off(), $o(null);
};
function Hr(e) {
  return e.vnode.shapeFlag & 4;
}
let Qt = !1;
function Jl(e, t = !1) {
  Qt = t;
  const { props: n, children: o } = e.vnode, s = Hr(e);
  Sl(e, n, s, t), Rl(e, o);
  const r = s ? Zl(e, t) : void 0;
  return Qt = !1, r;
}
function Zl(e, t) {
  const n = e.type;
  e.accessCache = /* @__PURE__ */ Object.create(null), e.proxy = nr(new Proxy(e.ctx, kl));
  const { setup: o } = n;
  if (o) {
    const s = e.setupContext = o.length > 1 ? Gl(e) : null;
    Ot(e), St();
    const r = Ge(
      o,
      e,
      0,
      [e.props, s]
    );
    if (Pt(), mt(), Ws(r)) {
      if (r.then(mt, mt), t)
        return r.then((i) => {
          ps(e, i, t);
        }).catch((i) => {
          Sn(i, e, 0);
        });
      e.asyncDep = r;
    } else
      ps(e, r, t);
  } else
    $r(e, t);
}
function ps(e, t, n) {
  W(t) ? e.type.__ssrInlineRender ? e.ssrRender = t : e.render = t : Z(t) && (e.setupState = ir(t)), $r(e, n);
}
let hs;
function $r(e, t, n) {
  const o = e.type;
  if (!e.render) {
    if (!t && hs && !o.render) {
      const s = o.template || Po(e).template;
      if (s) {
        const { isCustomElement: r, compilerOptions: i } = e.appContext.config, { delimiters: l, compilerOptions: a } = o, u = re(
          re(
            {
              isCustomElement: r,
              delimiters: l
            },
            i
          ),
          a
        );
        o.render = hs(s, u);
      }
    }
    e.render = o.render || Se;
  }
  Ot(e), St(), Cl(e), Pt(), mt();
}
function Ql(e) {
  return e.attrsProxy || (e.attrsProxy = new Proxy(
    e.attrs,
    {
      get(t, n) {
        return ye(e, "get", "$attrs"), t[n];
      }
    }
  ));
}
function Gl(e) {
  const t = (n) => {
    e.exposed = n || {};
  };
  return {
    get attrs() {
      return Ql(e);
    },
    slots: e.slots,
    emit: e.emit,
    expose: t
  };
}
function Nn(e) {
  if (e.exposed)
    return e.exposeProxy || (e.exposeProxy = new Proxy(ir(nr(e.exposed)), {
      get(t, n) {
        if (n in t)
          return t[n];
        if (n in Xt)
          return Xt[n](e);
      },
      has(t, n) {
        return n in t || n in Xt;
      }
    }));
}
function ea(e, t = !0) {
  return W(e) ? e.displayName || e.name : e.name || t && e.__name;
}
function ta(e) {
  return W(e) && "__vccOpts" in e;
}
const Xe = (e, t) => Ui(e, t, Qt);
function na(e, t, n) {
  const o = arguments.length;
  return o === 2 ? Z(t) && !$(t) ? kn(t) ? te(e, null, [t]) : te(e, t) : te(e, null, t) : (o > 3 ? n = Array.prototype.slice.call(arguments, 2) : o === 3 && kn(n) && (n = [n]), te(e, t, n));
}
const oa = Symbol.for("v-scx"), sa = () => jt(oa), ra = "3.3.4", ia = "http://www.w3.org/2000/svg", ft = typeof document < "u" ? document : null, gs = ft && /* @__PURE__ */ ft.createElement("template"), la = {
  insert: (e, t, n) => {
    t.insertBefore(e, n || null);
  },
  remove: (e) => {
    const t = e.parentNode;
    t && t.removeChild(e);
  },
  createElement: (e, t, n, o) => {
    const s = t ? ft.createElementNS(ia, e) : ft.createElement(e, n ? { is: n } : void 0);
    return e === "select" && o && o.multiple != null && s.setAttribute("multiple", o.multiple), s;
  },
  createText: (e) => ft.createTextNode(e),
  createComment: (e) => ft.createComment(e),
  setText: (e, t) => {
    e.nodeValue = t;
  },
  setElementText: (e, t) => {
    e.textContent = t;
  },
  parentNode: (e) => e.parentNode,
  nextSibling: (e) => e.nextSibling,
  querySelector: (e) => ft.querySelector(e),
  setScopeId(e, t) {
    e.setAttribute(t, "");
  },
  // __UNSAFE__
  // Reason: innerHTML.
  // Static content here can only come from compiled templates.
  // As long as the user only uses trusted templates, this is safe.
  insertStaticContent(e, t, n, o, s, r) {
    const i = n ? n.previousSibling : t.lastChild;
    if (s && (s === r || s.nextSibling))
      for (; t.insertBefore(s.cloneNode(!0), n), !(s === r || !(s = s.nextSibling)); )
        ;
    else {
      gs.innerHTML = o ? `<svg>${e}</svg>` : e;
      const l = gs.content;
      if (o) {
        const a = l.firstChild;
        for (; a.firstChild; )
          l.appendChild(a.firstChild);
        l.removeChild(a);
      }
      t.insertBefore(l, n);
    }
    return [
      // first
      i ? i.nextSibling : t.firstChild,
      // last
      n ? n.previousSibling : t.lastChild
    ];
  }
};
function aa(e, t, n) {
  const o = e._vtc;
  o && (t = (t ? [t, ...o] : [...o]).join(" ")), t == null ? e.removeAttribute("class") : n ? e.setAttribute("class", t) : e.className = t;
}
function ca(e, t, n) {
  const o = e.style, s = ie(n);
  if (n && !s) {
    if (t && !ie(t))
      for (const r in t)
        n[r] == null && fo(o, r, "");
    for (const r in n)
      fo(o, r, n[r]);
  } else {
    const r = o.display;
    s ? t !== n && (o.cssText = n) : t && e.removeAttribute("style"), "_vod" in e && (o.display = r);
  }
}
const ms = /\s*!important$/;
function fo(e, t, n) {
  if ($(n))
    n.forEach((o) => fo(e, t, o));
  else if (n == null && (n = ""), t.startsWith("--"))
    e.setProperty(t, n);
  else {
    const o = ua(e, t);
    ms.test(n) ? e.setProperty(
      bt(o),
      n.replace(ms, ""),
      "important"
    ) : e[o] = n;
  }
}
const bs = ["Webkit", "Moz", "ms"], Kn = {};
function ua(e, t) {
  const n = Kn[t];
  if (n)
    return n;
  let o = Ne(t);
  if (o !== "filter" && o in e)
    return Kn[t] = o;
  o = Mn(o);
  for (let s = 0; s < bs.length; s++) {
    const r = bs[s] + o;
    if (r in e)
      return Kn[t] = r;
  }
  return t;
}
const _s = "http://www.w3.org/1999/xlink";
function fa(e, t, n, o, s) {
  if (o && t.startsWith("xlink:"))
    n == null ? e.removeAttributeNS(_s, t.slice(6, t.length)) : e.setAttributeNS(_s, t, n);
  else {
    const r = ui(t);
    n == null || r && !Xs(n) ? e.removeAttribute(t) : e.setAttribute(t, r ? "" : n);
  }
}
function da(e, t, n, o, s, r, i) {
  if (t === "innerHTML" || t === "textContent") {
    o && i(o, s, r), e[t] = n ?? "";
    return;
  }
  const l = e.tagName;
  if (t === "value" && l !== "PROGRESS" && // custom elements may use _value internally
  !l.includes("-")) {
    e._value = n;
    const u = l === "OPTION" ? e.getAttribute("value") : e.value, f = n ?? "";
    u !== f && (e.value = f), n == null && e.removeAttribute(t);
    return;
  }
  let a = !1;
  if (n === "" || n == null) {
    const u = typeof e[t];
    u === "boolean" ? n = Xs(n) : n == null && u === "string" ? (n = "", a = !0) : u === "number" && (n = 0, a = !0);
  }
  try {
    e[t] = n;
  } catch {
  }
  a && e.removeAttribute(t);
}
function pa(e, t, n, o) {
  e.addEventListener(t, n, o);
}
function ha(e, t, n, o) {
  e.removeEventListener(t, n, o);
}
function ga(e, t, n, o, s = null) {
  const r = e._vei || (e._vei = {}), i = r[t];
  if (o && i)
    i.value = o;
  else {
    const [l, a] = ma(t);
    if (o) {
      const u = r[t] = va(o, s);
      pa(e, l, u, a);
    } else
      i && (ha(e, l, i, a), r[t] = void 0);
  }
}
const vs = /(?:Once|Passive|Capture)$/;
function ma(e) {
  let t;
  if (vs.test(e)) {
    t = {};
    let o;
    for (; o = e.match(vs); )
      e = e.slice(0, e.length - o[0].length), t[o[0].toLowerCase()] = !0;
  }
  return [e[2] === ":" ? e.slice(3) : bt(e.slice(2)), t];
}
let Un = 0;
const ba = /* @__PURE__ */ Promise.resolve(), _a = () => Un || (ba.then(() => Un = 0), Un = Date.now());
function va(e, t) {
  const n = (o) => {
    if (!o._vts)
      o._vts = Date.now();
    else if (o._vts <= n.attached)
      return;
    Te(
      ya(o, n.value),
      t,
      5,
      [o]
    );
  };
  return n.value = e, n.attached = _a(), n;
}
function ya(e, t) {
  if ($(t)) {
    const n = e.stopImmediatePropagation;
    return e.stopImmediatePropagation = () => {
      n.call(e), e._stopped = !0;
    }, t.map((o) => (s) => !s._stopped && o && o(s));
  } else
    return t;
}
const ys = /^on[a-z]/, wa = (e, t, n, o, s = !1, r, i, l, a) => {
  t === "class" ? aa(e, o, s) : t === "style" ? ca(e, n, o) : Tn(t) ? mo(t) || ga(e, t, n, o, i) : (t[0] === "." ? (t = t.slice(1), !0) : t[0] === "^" ? (t = t.slice(1), !1) : xa(e, t, o, s)) ? da(
    e,
    t,
    o,
    r,
    i,
    l,
    a
  ) : (t === "true-value" ? e._trueValue = o : t === "false-value" && (e._falseValue = o), fa(e, t, o, s));
};
function xa(e, t, n, o) {
  return o ? !!(t === "innerHTML" || t === "textContent" || t in e && ys.test(t) && W(n)) : t === "spellcheck" || t === "draggable" || t === "translate" || t === "form" || t === "list" && e.tagName === "INPUT" || t === "type" && e.tagName === "TEXTAREA" || ys.test(t) && ie(n) ? !1 : t in e;
}
const Ue = "transition", $t = "animation", Do = (e, { slots: t }) => na(fl, ka(e), t);
Do.displayName = "Transition";
const Dr = {
  name: String,
  type: String,
  css: {
    type: Boolean,
    default: !0
  },
  duration: [String, Number, Object],
  enterFromClass: String,
  enterActiveClass: String,
  enterToClass: String,
  appearFromClass: String,
  appearActiveClass: String,
  appearToClass: String,
  leaveFromClass: String,
  leaveActiveClass: String,
  leaveToClass: String
};
Do.props = /* @__PURE__ */ re(
  {},
  gr,
  Dr
);
const lt = (e, t = []) => {
  $(e) ? e.forEach((n) => n(...t)) : e && e(...t);
}, ws = (e) => e ? $(e) ? e.some((t) => t.length > 1) : e.length > 1 : !1;
function ka(e) {
  const t = {};
  for (const S in e)
    S in Dr || (t[S] = e[S]);
  if (e.css === !1)
    return t;
  const {
    name: n = "v",
    type: o,
    duration: s,
    enterFromClass: r = `${n}-enter-from`,
    enterActiveClass: i = `${n}-enter-active`,
    enterToClass: l = `${n}-enter-to`,
    appearFromClass: a = r,
    appearActiveClass: u = i,
    appearToClass: f = l,
    leaveFromClass: h = `${n}-leave-from`,
    leaveActiveClass: p = `${n}-leave-active`,
    leaveToClass: w = `${n}-leave-to`
  } = e, v = Ca(s), y = v && v[0], R = v && v[1], {
    onBeforeEnter: T,
    onEnter: E,
    onEnterCancelled: H,
    onLeave: O,
    onLeaveCancelled: V,
    onBeforeAppear: ue = T,
    onAppear: le = E,
    onAppearCancelled: D = H
  } = t, z = (S, Q, we) => {
    at(S, Q ? f : l), at(S, Q ? u : i), we && we();
  }, j = (S, Q) => {
    S._isLeaving = !1, at(S, h), at(S, w), at(S, p), Q && Q();
  }, ne = (S) => (Q, we) => {
    const Rt = S ? le : E, ae = () => z(Q, S, we);
    lt(Rt, [Q, ae]), xs(() => {
      at(Q, S ? a : r), Ve(Q, S ? f : l), ws(Rt) || ks(Q, o, y, ae);
    });
  };
  return re(t, {
    onBeforeEnter(S) {
      lt(T, [S]), Ve(S, r), Ve(S, i);
    },
    onBeforeAppear(S) {
      lt(ue, [S]), Ve(S, a), Ve(S, u);
    },
    onEnter: ne(!1),
    onAppear: ne(!0),
    onLeave(S, Q) {
      S._isLeaving = !0;
      const we = () => j(S, Q);
      Ve(S, h), Aa(), Ve(S, p), xs(() => {
        S._isLeaving && (at(S, h), Ve(S, w), ws(O) || ks(S, o, R, we));
      }), lt(O, [S, we]);
    },
    onEnterCancelled(S) {
      z(S, !1), lt(H, [S]);
    },
    onAppearCancelled(S) {
      z(S, !0), lt(D, [S]);
    },
    onLeaveCancelled(S) {
      j(S), lt(V, [S]);
    }
  });
}
function Ca(e) {
  if (e == null)
    return null;
  if (Z(e))
    return [Vn(e.enter), Vn(e.leave)];
  {
    const t = Vn(e);
    return [t, t];
  }
}
function Vn(e) {
  return si(e);
}
function Ve(e, t) {
  t.split(/\s+/).forEach((n) => n && e.classList.add(n)), (e._vtc || (e._vtc = /* @__PURE__ */ new Set())).add(t);
}
function at(e, t) {
  t.split(/\s+/).forEach((o) => o && e.classList.remove(o));
  const { _vtc: n } = e;
  n && (n.delete(t), n.size || (e._vtc = void 0));
}
function xs(e) {
  requestAnimationFrame(() => {
    requestAnimationFrame(e);
  });
}
let Ta = 0;
function ks(e, t, n, o) {
  const s = e._endId = ++Ta, r = () => {
    s === e._endId && o();
  };
  if (n)
    return setTimeout(r, n);
  const { type: i, timeout: l, propCount: a } = Ea(e, t);
  if (!i)
    return o();
  const u = i + "end";
  let f = 0;
  const h = () => {
    e.removeEventListener(u, p), r();
  }, p = (w) => {
    w.target === e && ++f >= a && h();
  };
  setTimeout(() => {
    f < a && h();
  }, l + 1), e.addEventListener(u, p);
}
function Ea(e, t) {
  const n = window.getComputedStyle(e), o = (v) => (n[v] || "").split(", "), s = o(`${Ue}Delay`), r = o(`${Ue}Duration`), i = Cs(s, r), l = o(`${$t}Delay`), a = o(`${$t}Duration`), u = Cs(l, a);
  let f = null, h = 0, p = 0;
  t === Ue ? i > 0 && (f = Ue, h = i, p = r.length) : t === $t ? u > 0 && (f = $t, h = u, p = a.length) : (h = Math.max(i, u), f = h > 0 ? i > u ? Ue : $t : null, p = f ? f === Ue ? r.length : a.length : 0);
  const w = f === Ue && /\b(transform|all)(,|$)/.test(
    o(`${Ue}Property`).toString()
  );
  return {
    type: f,
    timeout: h,
    propCount: p,
    hasTransform: w
  };
}
function Cs(e, t) {
  for (; e.length < t.length; )
    e = e.concat(e);
  return Math.max(...t.map((n, o) => Ts(n) + Ts(e[o])));
}
function Ts(e) {
  return Number(e.slice(0, -1).replace(",", ".")) * 1e3;
}
function Aa() {
  return document.body.offsetHeight;
}
const Ma = ["ctrl", "shift", "alt", "meta"], Oa = {
  stop: (e) => e.stopPropagation(),
  prevent: (e) => e.preventDefault(),
  self: (e) => e.target !== e.currentTarget,
  ctrl: (e) => !e.ctrlKey,
  shift: (e) => !e.shiftKey,
  alt: (e) => !e.altKey,
  meta: (e) => !e.metaKey,
  left: (e) => "button" in e && e.button !== 0,
  middle: (e) => "button" in e && e.button !== 1,
  right: (e) => "button" in e && e.button !== 2,
  exact: (e, t) => Ma.some((n) => e[`${n}Key`] && !t.includes(n))
}, Nr = (e, t) => (n, ...o) => {
  for (let s = 0; s < t.length; s++) {
    const r = Oa[t[s]];
    if (r && r(n, t))
      return;
  }
  return e(n, ...o);
}, La = {
  esc: "escape",
  space: " ",
  up: "arrow-up",
  left: "arrow-left",
  right: "arrow-right",
  down: "arrow-down",
  delete: "backspace"
}, Sa = (e, t) => (n) => {
  if (!("key" in n))
    return;
  const o = bt(n.key);
  if (t.some((s) => s === o || La[s] === o))
    return e(n);
}, po = {
  beforeMount(e, { value: t }, { transition: n }) {
    e._vod = e.style.display === "none" ? "" : e.style.display, n && t ? n.beforeEnter(e) : Dt(e, t);
  },
  mounted(e, { value: t }, { transition: n }) {
    n && t && n.enter(e);
  },
  updated(e, { value: t, oldValue: n }, { transition: o }) {
    !t != !n && (o ? t ? (o.beforeEnter(e), Dt(e, !0), o.enter(e)) : o.leave(e, () => {
      Dt(e, !1);
    }) : Dt(e, t));
  },
  beforeUnmount(e, { value: t }) {
    Dt(e, t);
  }
};
function Dt(e, t) {
  e.style.display = t ? e._vod : "none";
}
const Pa = /* @__PURE__ */ re({ patchProp: wa }, la);
let Es;
function Ia() {
  return Es || (Es = $l(Pa));
}
const Ra = (...e) => {
  const t = Ia().createApp(...e), { mount: n } = t;
  return t.mount = (o) => {
    const s = Ha(o);
    if (!s)
      return;
    const r = t._component;
    !W(r) && !r.render && !r.template && (r.template = s.innerHTML), s.innerHTML = "";
    const i = n(s, !1, s instanceof SVGElement);
    return s instanceof Element && (s.removeAttribute("v-cloak"), s.setAttribute("data-v-app", "")), i;
  }, t;
};
function Ha(e) {
  return ie(e) ? document.querySelector(e) : e;
}
const $a = { class: "consent-container" }, Da = {
  class: "modal-backdrop",
  ref: "modal-backdrop"
}, Na = {
  class: "modal-container",
  role: "dialog",
  ref: "modal",
  "aria-modal": "true",
  "aria-labelledby": "modal-headline"
}, Fa = /* @__PURE__ */ Lo({
  __name: "ModalDialog",
  props: {
    visible: {
      type: Boolean
    }
  },
  emits: ["closeModal"],
  setup(e, { emit: t }) {
    const n = () => {
      t("closeModal");
    };
    return (o, s) => (be(), gt(Bl, { to: "body" }, [
      M("div", $a, [
        no(M("div", Da, [
          M("div", null, [
            te(Do, {
              "enter-active-class": "transition ease-out duration-300 transform",
              "enter-from-class": "opacity-0 translate-y-10 scale-95",
              "enter-to-class": "opacity-100 translate-y-0 scale-100",
              "leave-active-class": "ease-in duration-200",
              "leave-from-class": "opacity-100 translate-y-0 scale-100",
              "leave-to-class": "opacity-0 translate-y-10 translate-y-0 scale-95"
            }, {
              default: fe(() => [
                no(M("div", Na, [
                  M("button", { class: "btn-close-modal" }, [
                    M("span", {
                      class: "close-modal",
                      onClick: n
                    }, "X")
                  ]),
                  At(o.$slots, "default", {}, () => [
                    me("I'm empty inside")
                  ])
                ], 512), [
                  [po, e.visible]
                ])
              ]),
              _: 3
            })
          ])
        ], 512), [
          [po, e.visible]
        ])
      ])
    ]));
  }
});
/*!
 * perfect-scrollbar v1.5.3
 * Copyright 2021 Hyunje Jun, MDBootstrap and Contributors
 * Licensed under MIT
 */
function De(e) {
  return getComputedStyle(e);
}
function ve(e, t) {
  for (var n in t) {
    var o = t[n];
    typeof o == "number" && (o = o + "px"), e.style[n] = o;
  }
  return e;
}
function fn(e) {
  var t = document.createElement("div");
  return t.className = e, t;
}
var As = typeof Element < "u" && (Element.prototype.matches || Element.prototype.webkitMatchesSelector || Element.prototype.mozMatchesSelector || Element.prototype.msMatchesSelector);
function Ze(e, t) {
  if (!As)
    throw new Error("No element matching method supported");
  return As.call(e, t);
}
function xt(e) {
  e.remove ? e.remove() : e.parentNode && e.parentNode.removeChild(e);
}
function Ms(e, t) {
  return Array.prototype.filter.call(
    e.children,
    function(n) {
      return Ze(n, t);
    }
  );
}
var se = {
  main: "ps",
  rtl: "ps__rtl",
  element: {
    thumb: function(e) {
      return "ps__thumb-" + e;
    },
    rail: function(e) {
      return "ps__rail-" + e;
    },
    consuming: "ps__child--consume"
  },
  state: {
    focus: "ps--focus",
    clicking: "ps--clicking",
    active: function(e) {
      return "ps--active-" + e;
    },
    scrolling: function(e) {
      return "ps--scrolling-" + e;
    }
  }
}, Fr = { x: null, y: null };
function Wr(e, t) {
  var n = e.element.classList, o = se.state.scrolling(t);
  n.contains(o) ? clearTimeout(Fr[t]) : n.add(o);
}
function Yr(e, t) {
  Fr[t] = setTimeout(
    function() {
      return e.isAlive && e.element.classList.remove(se.state.scrolling(t));
    },
    e.settings.scrollingThreshold
  );
}
function Wa(e, t) {
  Wr(e, t), Yr(e, t);
}
var Gt = function(t) {
  this.element = t, this.handlers = {};
}, Br = { isEmpty: { configurable: !0 } };
Gt.prototype.bind = function(t, n) {
  typeof this.handlers[t] > "u" && (this.handlers[t] = []), this.handlers[t].push(n), this.element.addEventListener(t, n, !1);
};
Gt.prototype.unbind = function(t, n) {
  var o = this;
  this.handlers[t] = this.handlers[t].filter(function(s) {
    return n && s !== n ? !0 : (o.element.removeEventListener(t, s, !1), !1);
  });
};
Gt.prototype.unbindAll = function() {
  for (var t in this.handlers)
    this.unbind(t);
};
Br.isEmpty.get = function() {
  var e = this;
  return Object.keys(this.handlers).every(
    function(t) {
      return e.handlers[t].length === 0;
    }
  );
};
Object.defineProperties(Gt.prototype, Br);
var It = function() {
  this.eventElements = [];
};
It.prototype.eventElement = function(t) {
  var n = this.eventElements.filter(function(o) {
    return o.element === t;
  })[0];
  return n || (n = new Gt(t), this.eventElements.push(n)), n;
};
It.prototype.bind = function(t, n, o) {
  this.eventElement(t).bind(n, o);
};
It.prototype.unbind = function(t, n, o) {
  var s = this.eventElement(t);
  s.unbind(n, o), s.isEmpty && this.eventElements.splice(this.eventElements.indexOf(s), 1);
};
It.prototype.unbindAll = function() {
  this.eventElements.forEach(function(t) {
    return t.unbindAll();
  }), this.eventElements = [];
};
It.prototype.once = function(t, n, o) {
  var s = this.eventElement(t), r = function(i) {
    s.unbind(n, r), o(i);
  };
  s.bind(n, r);
};
function dn(e) {
  if (typeof window.CustomEvent == "function")
    return new CustomEvent(e);
  var t = document.createEvent("CustomEvent");
  return t.initCustomEvent(e, !1, !1, void 0), t;
}
function Cn(e, t, n, o, s) {
  o === void 0 && (o = !0), s === void 0 && (s = !1);
  var r;
  if (t === "top")
    r = [
      "contentHeight",
      "containerHeight",
      "scrollTop",
      "y",
      "up",
      "down"
    ];
  else if (t === "left")
    r = [
      "contentWidth",
      "containerWidth",
      "scrollLeft",
      "x",
      "left",
      "right"
    ];
  else
    throw new Error("A proper axis should be provided");
  Ya(e, n, r, o, s);
}
function Ya(e, t, n, o, s) {
  var r = n[0], i = n[1], l = n[2], a = n[3], u = n[4], f = n[5];
  o === void 0 && (o = !0), s === void 0 && (s = !1);
  var h = e.element;
  e.reach[a] = null, h[l] < 1 && (e.reach[a] = "start"), h[l] > e[r] - e[i] - 1 && (e.reach[a] = "end"), t && (h.dispatchEvent(dn("ps-scroll-" + a)), t < 0 ? h.dispatchEvent(dn("ps-scroll-" + u)) : t > 0 && h.dispatchEvent(dn("ps-scroll-" + f)), o && Wa(e, a)), e.reach[a] && (t || s) && h.dispatchEvent(dn("ps-" + a + "-reach-" + e.reach[a]));
}
function G(e) {
  return parseInt(e, 10) || 0;
}
function Ba(e) {
  return Ze(e, "input,[contenteditable]") || Ze(e, "select,[contenteditable]") || Ze(e, "textarea,[contenteditable]") || Ze(e, "button,[contenteditable]");
}
function Xa(e) {
  var t = De(e);
  return G(t.width) + G(t.paddingLeft) + G(t.paddingRight) + G(t.borderLeftWidth) + G(t.borderRightWidth);
}
var wt = {
  isWebKit: typeof document < "u" && "WebkitAppearance" in document.documentElement.style,
  supportsTouch: typeof window < "u" && ("ontouchstart" in window || "maxTouchPoints" in window.navigator && window.navigator.maxTouchPoints > 0 || window.DocumentTouch && document instanceof window.DocumentTouch),
  supportsIePointer: typeof navigator < "u" && navigator.msMaxTouchPoints,
  isChrome: typeof navigator < "u" && /Chrome/i.test(navigator && navigator.userAgent)
};
function ze(e) {
  var t = e.element, n = Math.floor(t.scrollTop), o = t.getBoundingClientRect();
  e.containerWidth = Math.round(o.width), e.containerHeight = Math.round(o.height), e.contentWidth = t.scrollWidth, e.contentHeight = t.scrollHeight, t.contains(e.scrollbarXRail) || (Ms(t, se.element.rail("x")).forEach(
    function(s) {
      return xt(s);
    }
  ), t.appendChild(e.scrollbarXRail)), t.contains(e.scrollbarYRail) || (Ms(t, se.element.rail("y")).forEach(
    function(s) {
      return xt(s);
    }
  ), t.appendChild(e.scrollbarYRail)), !e.settings.suppressScrollX && e.containerWidth + e.settings.scrollXMarginOffset < e.contentWidth ? (e.scrollbarXActive = !0, e.railXWidth = e.containerWidth - e.railXMarginWidth, e.railXRatio = e.containerWidth / e.railXWidth, e.scrollbarXWidth = Os(
    e,
    G(e.railXWidth * e.containerWidth / e.contentWidth)
  ), e.scrollbarXLeft = G(
    (e.negativeScrollAdjustment + t.scrollLeft) * (e.railXWidth - e.scrollbarXWidth) / (e.contentWidth - e.containerWidth)
  )) : e.scrollbarXActive = !1, !e.settings.suppressScrollY && e.containerHeight + e.settings.scrollYMarginOffset < e.contentHeight ? (e.scrollbarYActive = !0, e.railYHeight = e.containerHeight - e.railYMarginHeight, e.railYRatio = e.containerHeight / e.railYHeight, e.scrollbarYHeight = Os(
    e,
    G(e.railYHeight * e.containerHeight / e.contentHeight)
  ), e.scrollbarYTop = G(
    n * (e.railYHeight - e.scrollbarYHeight) / (e.contentHeight - e.containerHeight)
  )) : e.scrollbarYActive = !1, e.scrollbarXLeft >= e.railXWidth - e.scrollbarXWidth && (e.scrollbarXLeft = e.railXWidth - e.scrollbarXWidth), e.scrollbarYTop >= e.railYHeight - e.scrollbarYHeight && (e.scrollbarYTop = e.railYHeight - e.scrollbarYHeight), ja(t, e), e.scrollbarXActive ? t.classList.add(se.state.active("x")) : (t.classList.remove(se.state.active("x")), e.scrollbarXWidth = 0, e.scrollbarXLeft = 0, t.scrollLeft = e.isRtl === !0 ? e.contentWidth : 0), e.scrollbarYActive ? t.classList.add(se.state.active("y")) : (t.classList.remove(se.state.active("y")), e.scrollbarYHeight = 0, e.scrollbarYTop = 0, t.scrollTop = 0);
}
function Os(e, t) {
  return e.settings.minScrollbarLength && (t = Math.max(t, e.settings.minScrollbarLength)), e.settings.maxScrollbarLength && (t = Math.min(t, e.settings.maxScrollbarLength)), t;
}
function ja(e, t) {
  var n = { width: t.railXWidth }, o = Math.floor(e.scrollTop);
  t.isRtl ? n.left = t.negativeScrollAdjustment + e.scrollLeft + t.containerWidth - t.contentWidth : n.left = e.scrollLeft, t.isScrollbarXUsingBottom ? n.bottom = t.scrollbarXBottom - o : n.top = t.scrollbarXTop + o, ve(t.scrollbarXRail, n);
  var s = { top: o, height: t.railYHeight };
  t.isScrollbarYUsingRight ? t.isRtl ? s.right = t.contentWidth - (t.negativeScrollAdjustment + e.scrollLeft) - t.scrollbarYRight - t.scrollbarYOuterWidth - 9 : s.right = t.scrollbarYRight - e.scrollLeft : t.isRtl ? s.left = t.negativeScrollAdjustment + e.scrollLeft + t.containerWidth * 2 - t.contentWidth - t.scrollbarYLeft - t.scrollbarYOuterWidth : s.left = t.scrollbarYLeft + e.scrollLeft, ve(t.scrollbarYRail, s), ve(t.scrollbarX, {
    left: t.scrollbarXLeft,
    width: t.scrollbarXWidth - t.railBorderXWidth
  }), ve(t.scrollbarY, {
    top: t.scrollbarYTop,
    height: t.scrollbarYHeight - t.railBorderYWidth
  });
}
function za(e) {
  e.element, e.event.bind(e.scrollbarY, "mousedown", function(t) {
    return t.stopPropagation();
  }), e.event.bind(e.scrollbarYRail, "mousedown", function(t) {
    var n = t.pageY - window.pageYOffset - e.scrollbarYRail.getBoundingClientRect().top, o = n > e.scrollbarYTop ? 1 : -1;
    e.element.scrollTop += o * e.containerHeight, ze(e), t.stopPropagation();
  }), e.event.bind(e.scrollbarX, "mousedown", function(t) {
    return t.stopPropagation();
  }), e.event.bind(e.scrollbarXRail, "mousedown", function(t) {
    var n = t.pageX - window.pageXOffset - e.scrollbarXRail.getBoundingClientRect().left, o = n > e.scrollbarXLeft ? 1 : -1;
    e.element.scrollLeft += o * e.containerWidth, ze(e), t.stopPropagation();
  });
}
function qa(e) {
  Ls(e, [
    "containerWidth",
    "contentWidth",
    "pageX",
    "railXWidth",
    "scrollbarX",
    "scrollbarXWidth",
    "scrollLeft",
    "x",
    "scrollbarXRail"
  ]), Ls(e, [
    "containerHeight",
    "contentHeight",
    "pageY",
    "railYHeight",
    "scrollbarY",
    "scrollbarYHeight",
    "scrollTop",
    "y",
    "scrollbarYRail"
  ]);
}
function Ls(e, t) {
  var n = t[0], o = t[1], s = t[2], r = t[3], i = t[4], l = t[5], a = t[6], u = t[7], f = t[8], h = e.element, p = null, w = null, v = null;
  function y(E) {
    E.touches && E.touches[0] && (E[s] = E.touches[0].pageY), h[a] = p + v * (E[s] - w), Wr(e, u), ze(e), E.stopPropagation(), E.type.startsWith("touch") && E.changedTouches.length > 1 && E.preventDefault();
  }
  function R() {
    Yr(e, u), e[f].classList.remove(se.state.clicking), e.event.unbind(e.ownerDocument, "mousemove", y);
  }
  function T(E, H) {
    p = h[a], H && E.touches && (E[s] = E.touches[0].pageY), w = E[s], v = (e[o] - e[n]) / (e[r] - e[l]), H ? e.event.bind(e.ownerDocument, "touchmove", y) : (e.event.bind(e.ownerDocument, "mousemove", y), e.event.once(e.ownerDocument, "mouseup", R), E.preventDefault()), e[f].classList.add(se.state.clicking), E.stopPropagation();
  }
  e.event.bind(e[i], "mousedown", function(E) {
    T(E);
  }), e.event.bind(e[i], "touchstart", function(E) {
    T(E, !0);
  });
}
function Ka(e) {
  var t = e.element, n = function() {
    return Ze(t, ":hover");
  }, o = function() {
    return Ze(e.scrollbarX, ":focus") || Ze(e.scrollbarY, ":focus");
  };
  function s(r, i) {
    var l = Math.floor(t.scrollTop);
    if (r === 0) {
      if (!e.scrollbarYActive)
        return !1;
      if (l === 0 && i > 0 || l >= e.contentHeight - e.containerHeight && i < 0)
        return !e.settings.wheelPropagation;
    }
    var a = t.scrollLeft;
    if (i === 0) {
      if (!e.scrollbarXActive)
        return !1;
      if (a === 0 && r < 0 || a >= e.contentWidth - e.containerWidth && r > 0)
        return !e.settings.wheelPropagation;
    }
    return !0;
  }
  e.event.bind(e.ownerDocument, "keydown", function(r) {
    if (!(r.isDefaultPrevented && r.isDefaultPrevented() || r.defaultPrevented) && !(!n() && !o())) {
      var i = document.activeElement ? document.activeElement : e.ownerDocument.activeElement;
      if (i) {
        if (i.tagName === "IFRAME")
          i = i.contentDocument.activeElement;
        else
          for (; i.shadowRoot; )
            i = i.shadowRoot.activeElement;
        if (Ba(i))
          return;
      }
      var l = 0, a = 0;
      switch (r.which) {
        case 37:
          r.metaKey ? l = -e.contentWidth : r.altKey ? l = -e.containerWidth : l = -30;
          break;
        case 38:
          r.metaKey ? a = e.contentHeight : r.altKey ? a = e.containerHeight : a = 30;
          break;
        case 39:
          r.metaKey ? l = e.contentWidth : r.altKey ? l = e.containerWidth : l = 30;
          break;
        case 40:
          r.metaKey ? a = -e.contentHeight : r.altKey ? a = -e.containerHeight : a = -30;
          break;
        case 32:
          r.shiftKey ? a = e.containerHeight : a = -e.containerHeight;
          break;
        case 33:
          a = e.containerHeight;
          break;
        case 34:
          a = -e.containerHeight;
          break;
        case 36:
          a = e.contentHeight;
          break;
        case 35:
          a = -e.contentHeight;
          break;
        default:
          return;
      }
      e.settings.suppressScrollX && l !== 0 || e.settings.suppressScrollY && a !== 0 || (t.scrollTop -= a, t.scrollLeft += l, ze(e), s(l, a) && r.preventDefault());
    }
  });
}
function Ua(e) {
  var t = e.element;
  function n(i, l) {
    var a = Math.floor(t.scrollTop), u = t.scrollTop === 0, f = a + t.offsetHeight === t.scrollHeight, h = t.scrollLeft === 0, p = t.scrollLeft + t.offsetWidth === t.scrollWidth, w;
    return Math.abs(l) > Math.abs(i) ? w = u || f : w = h || p, w ? !e.settings.wheelPropagation : !0;
  }
  function o(i) {
    var l = i.deltaX, a = -1 * i.deltaY;
    return (typeof l > "u" || typeof a > "u") && (l = -1 * i.wheelDeltaX / 6, a = i.wheelDeltaY / 6), i.deltaMode && i.deltaMode === 1 && (l *= 10, a *= 10), l !== l && a !== a && (l = 0, a = i.wheelDelta), i.shiftKey ? [-a, -l] : [l, a];
  }
  function s(i, l, a) {
    if (!wt.isWebKit && t.querySelector("select:focus"))
      return !0;
    if (!t.contains(i))
      return !1;
    for (var u = i; u && u !== t; ) {
      if (u.classList.contains(se.element.consuming))
        return !0;
      var f = De(u);
      if (a && f.overflowY.match(/(scroll|auto)/)) {
        var h = u.scrollHeight - u.clientHeight;
        if (h > 0 && (u.scrollTop > 0 && a < 0 || u.scrollTop < h && a > 0))
          return !0;
      }
      if (l && f.overflowX.match(/(scroll|auto)/)) {
        var p = u.scrollWidth - u.clientWidth;
        if (p > 0 && (u.scrollLeft > 0 && l < 0 || u.scrollLeft < p && l > 0))
          return !0;
      }
      u = u.parentNode;
    }
    return !1;
  }
  function r(i) {
    var l = o(i), a = l[0], u = l[1];
    if (!s(i.target, a, u)) {
      var f = !1;
      e.settings.useBothWheelAxes ? e.scrollbarYActive && !e.scrollbarXActive ? (u ? t.scrollTop -= u * e.settings.wheelSpeed : t.scrollTop += a * e.settings.wheelSpeed, f = !0) : e.scrollbarXActive && !e.scrollbarYActive && (a ? t.scrollLeft += a * e.settings.wheelSpeed : t.scrollLeft -= u * e.settings.wheelSpeed, f = !0) : (t.scrollTop -= u * e.settings.wheelSpeed, t.scrollLeft += a * e.settings.wheelSpeed), ze(e), f = f || n(a, u), f && !i.ctrlKey && (i.stopPropagation(), i.preventDefault());
    }
  }
  typeof window.onwheel < "u" ? e.event.bind(t, "wheel", r) : typeof window.onmousewheel < "u" && e.event.bind(t, "mousewheel", r);
}
function Va(e) {
  if (!wt.supportsTouch && !wt.supportsIePointer)
    return;
  var t = e.element;
  function n(v, y) {
    var R = Math.floor(t.scrollTop), T = t.scrollLeft, E = Math.abs(v), H = Math.abs(y);
    if (H > E) {
      if (y < 0 && R === e.contentHeight - e.containerHeight || y > 0 && R === 0)
        return window.scrollY === 0 && y > 0 && wt.isChrome;
    } else if (E > H && (v < 0 && T === e.contentWidth - e.containerWidth || v > 0 && T === 0))
      return !0;
    return !0;
  }
  function o(v, y) {
    t.scrollTop -= y, t.scrollLeft -= v, ze(e);
  }
  var s = {}, r = 0, i = {}, l = null;
  function a(v) {
    return v.targetTouches ? v.targetTouches[0] : v;
  }
  function u(v) {
    return v.pointerType && v.pointerType === "pen" && v.buttons === 0 ? !1 : !!(v.targetTouches && v.targetTouches.length === 1 || v.pointerType && v.pointerType !== "mouse" && v.pointerType !== v.MSPOINTER_TYPE_MOUSE);
  }
  function f(v) {
    if (u(v)) {
      var y = a(v);
      s.pageX = y.pageX, s.pageY = y.pageY, r = (/* @__PURE__ */ new Date()).getTime(), l !== null && clearInterval(l);
    }
  }
  function h(v, y, R) {
    if (!t.contains(v))
      return !1;
    for (var T = v; T && T !== t; ) {
      if (T.classList.contains(se.element.consuming))
        return !0;
      var E = De(T);
      if (R && E.overflowY.match(/(scroll|auto)/)) {
        var H = T.scrollHeight - T.clientHeight;
        if (H > 0 && (T.scrollTop > 0 && R < 0 || T.scrollTop < H && R > 0))
          return !0;
      }
      if (y && E.overflowX.match(/(scroll|auto)/)) {
        var O = T.scrollWidth - T.clientWidth;
        if (O > 0 && (T.scrollLeft > 0 && y < 0 || T.scrollLeft < O && y > 0))
          return !0;
      }
      T = T.parentNode;
    }
    return !1;
  }
  function p(v) {
    if (u(v)) {
      var y = a(v), R = { pageX: y.pageX, pageY: y.pageY }, T = R.pageX - s.pageX, E = R.pageY - s.pageY;
      if (h(v.target, T, E))
        return;
      o(T, E), s = R;
      var H = (/* @__PURE__ */ new Date()).getTime(), O = H - r;
      O > 0 && (i.x = T / O, i.y = E / O, r = H), n(T, E) && v.preventDefault();
    }
  }
  function w() {
    e.settings.swipeEasing && (clearInterval(l), l = setInterval(function() {
      if (e.isInitialized) {
        clearInterval(l);
        return;
      }
      if (!i.x && !i.y) {
        clearInterval(l);
        return;
      }
      if (Math.abs(i.x) < 0.01 && Math.abs(i.y) < 0.01) {
        clearInterval(l);
        return;
      }
      if (!e.element) {
        clearInterval(l);
        return;
      }
      o(i.x * 30, i.y * 30), i.x *= 0.8, i.y *= 0.8;
    }, 10));
  }
  wt.supportsTouch ? (e.event.bind(t, "touchstart", f), e.event.bind(t, "touchmove", p), e.event.bind(t, "touchend", w)) : wt.supportsIePointer && (window.PointerEvent ? (e.event.bind(t, "pointerdown", f), e.event.bind(t, "pointermove", p), e.event.bind(t, "pointerup", w)) : window.MSPointerEvent && (e.event.bind(t, "MSPointerDown", f), e.event.bind(t, "MSPointerMove", p), e.event.bind(t, "MSPointerUp", w)));
}
var Ja = function() {
  return {
    handlers: ["click-rail", "drag-thumb", "keyboard", "wheel", "touch"],
    maxScrollbarLength: null,
    minScrollbarLength: null,
    scrollingThreshold: 1e3,
    scrollXMarginOffset: 0,
    scrollYMarginOffset: 0,
    suppressScrollX: !1,
    suppressScrollY: !1,
    swipeEasing: !0,
    useBothWheelAxes: !1,
    wheelPropagation: !0,
    wheelSpeed: 1
  };
}, Za = {
  "click-rail": za,
  "drag-thumb": qa,
  keyboard: Ka,
  wheel: Ua,
  touch: Va
}, Lt = function(t, n) {
  var o = this;
  if (n === void 0 && (n = {}), typeof t == "string" && (t = document.querySelector(t)), !t || !t.nodeName)
    throw new Error("no element is specified to initialize PerfectScrollbar");
  this.element = t, t.classList.add(se.main), this.settings = Ja();
  for (var s in n)
    this.settings[s] = n[s];
  this.containerWidth = null, this.containerHeight = null, this.contentWidth = null, this.contentHeight = null;
  var r = function() {
    return t.classList.add(se.state.focus);
  }, i = function() {
    return t.classList.remove(se.state.focus);
  };
  this.isRtl = De(t).direction === "rtl", this.isRtl === !0 && t.classList.add(se.rtl), this.isNegativeScroll = function() {
    var u = t.scrollLeft, f = null;
    return t.scrollLeft = -1, f = t.scrollLeft < 0, t.scrollLeft = u, f;
  }(), this.negativeScrollAdjustment = this.isNegativeScroll ? t.scrollWidth - t.clientWidth : 0, this.event = new It(), this.ownerDocument = t.ownerDocument || document, this.scrollbarXRail = fn(se.element.rail("x")), t.appendChild(this.scrollbarXRail), this.scrollbarX = fn(se.element.thumb("x")), this.scrollbarXRail.appendChild(this.scrollbarX), this.scrollbarX.setAttribute("tabindex", 0), this.event.bind(this.scrollbarX, "focus", r), this.event.bind(this.scrollbarX, "blur", i), this.scrollbarXActive = null, this.scrollbarXWidth = null, this.scrollbarXLeft = null;
  var l = De(this.scrollbarXRail);
  this.scrollbarXBottom = parseInt(l.bottom, 10), isNaN(this.scrollbarXBottom) ? (this.isScrollbarXUsingBottom = !1, this.scrollbarXTop = G(l.top)) : this.isScrollbarXUsingBottom = !0, this.railBorderXWidth = G(l.borderLeftWidth) + G(l.borderRightWidth), ve(this.scrollbarXRail, { display: "block" }), this.railXMarginWidth = G(l.marginLeft) + G(l.marginRight), ve(this.scrollbarXRail, { display: "" }), this.railXWidth = null, this.railXRatio = null, this.scrollbarYRail = fn(se.element.rail("y")), t.appendChild(this.scrollbarYRail), this.scrollbarY = fn(se.element.thumb("y")), this.scrollbarYRail.appendChild(this.scrollbarY), this.scrollbarY.setAttribute("tabindex", 0), this.event.bind(this.scrollbarY, "focus", r), this.event.bind(this.scrollbarY, "blur", i), this.scrollbarYActive = null, this.scrollbarYHeight = null, this.scrollbarYTop = null;
  var a = De(this.scrollbarYRail);
  this.scrollbarYRight = parseInt(a.right, 10), isNaN(this.scrollbarYRight) ? (this.isScrollbarYUsingRight = !1, this.scrollbarYLeft = G(a.left)) : this.isScrollbarYUsingRight = !0, this.scrollbarYOuterWidth = this.isRtl ? Xa(this.scrollbarY) : null, this.railBorderYWidth = G(a.borderTopWidth) + G(a.borderBottomWidth), ve(this.scrollbarYRail, { display: "block" }), this.railYMarginHeight = G(a.marginTop) + G(a.marginBottom), ve(this.scrollbarYRail, { display: "" }), this.railYHeight = null, this.railYRatio = null, this.reach = {
    x: t.scrollLeft <= 0 ? "start" : t.scrollLeft >= this.contentWidth - this.containerWidth ? "end" : null,
    y: t.scrollTop <= 0 ? "start" : t.scrollTop >= this.contentHeight - this.containerHeight ? "end" : null
  }, this.isAlive = !0, this.settings.handlers.forEach(function(u) {
    return Za[u](o);
  }), this.lastScrollTop = Math.floor(t.scrollTop), this.lastScrollLeft = t.scrollLeft, this.event.bind(this.element, "scroll", function(u) {
    return o.onScroll(u);
  }), ze(this);
};
Lt.prototype.update = function() {
  this.isAlive && (this.negativeScrollAdjustment = this.isNegativeScroll ? this.element.scrollWidth - this.element.clientWidth : 0, ve(this.scrollbarXRail, { display: "block" }), ve(this.scrollbarYRail, { display: "block" }), this.railXMarginWidth = G(De(this.scrollbarXRail).marginLeft) + G(De(this.scrollbarXRail).marginRight), this.railYMarginHeight = G(De(this.scrollbarYRail).marginTop) + G(De(this.scrollbarYRail).marginBottom), ve(this.scrollbarXRail, { display: "none" }), ve(this.scrollbarYRail, { display: "none" }), ze(this), Cn(this, "top", 0, !1, !0), Cn(this, "left", 0, !1, !0), ve(this.scrollbarXRail, { display: "" }), ve(this.scrollbarYRail, { display: "" }));
};
Lt.prototype.onScroll = function(t) {
  this.isAlive && (ze(this), Cn(this, "top", this.element.scrollTop - this.lastScrollTop), Cn(
    this,
    "left",
    this.element.scrollLeft - this.lastScrollLeft
  ), this.lastScrollTop = Math.floor(this.element.scrollTop), this.lastScrollLeft = this.element.scrollLeft);
};
Lt.prototype.destroy = function() {
  this.isAlive && (this.event.unbindAll(), xt(this.scrollbarX), xt(this.scrollbarY), xt(this.scrollbarXRail), xt(this.scrollbarYRail), this.removePsClasses(), this.element = null, this.scrollbarX = null, this.scrollbarY = null, this.scrollbarXRail = null, this.scrollbarYRail = null, this.isAlive = !1);
};
Lt.prototype.removePsClasses = function() {
  this.element.className = this.element.className.split(" ").filter(function(t) {
    return !t.match(/^ps([-_].+|)$/);
  }).join(" ");
};
var ho = { name: "Toggle", emits: ["input", "update:modelValue", "change"], props: { value: { validator: function(e) {
  return (t) => ["number", "string", "boolean"].indexOf(typeof t) !== -1 || t == null;
}, required: !1 }, modelValue: { validator: function(e) {
  return (t) => ["number", "string", "boolean"].indexOf(typeof t) !== -1 || t == null;
}, required: !1 }, id: { type: [String, Number], required: !1, default: "toggle" }, name: { type: [String, Number], required: !1, default: "toggle" }, disabled: { type: Boolean, required: !1, default: !1 }, required: { type: Boolean, required: !1, default: !1 }, falseValue: { type: [String, Number, Boolean], required: !1, default: !1 }, trueValue: { type: [String, Number, Boolean], required: !1, default: !0 }, onLabel: { type: [String, Object], required: !1, default: "" }, offLabel: { type: [String, Object], required: !1, default: "" }, classes: { type: Object, required: !1, default: () => ({}) }, labelledby: { type: String, required: !1 }, describedby: { type: String, required: !1 }, aria: { required: !1, type: Object, default: () => ({}) } }, setup(e, t) {
  const n = function(i, l, a) {
    const { value: u, modelValue: f, falseValue: h, trueValue: p, disabled: w } = an(i), v = f && f.value !== void 0 ? f : u, y = Xe(() => v.value === p.value), R = (H) => {
      l.emit("input", H), l.emit("update:modelValue", H), l.emit("change", H);
    }, T = () => {
      R(p.value);
    }, E = () => {
      R(h.value);
    };
    return [null, void 0, !1, 0, "0", "off"].indexOf(v.value) !== -1 && [h.value, p.value].indexOf(v.value) === -1 && E(), [!0, 1, "1", "on"].indexOf(v.value) !== -1 && [h.value, p.value].indexOf(v.value) === -1 && T(), { externalValue: v, checked: y, update: R, check: T, uncheck: E, handleInput: (H) => {
      R(H.target.checked ? p.value : h.value);
    }, handleClick: () => {
      w.value || (y.value ? E() : T());
    } };
  }(e, t), o = function(i, l, a) {
    const { trueValue: u, falseValue: f, onLabel: h, offLabel: p } = an(i), w = a.checked, v = a.update;
    return { label: Xe(() => {
      let y = w.value ? h.value : p.value;
      return y || (y = "&nbsp;"), y;
    }), toggle: () => {
      v(w.value ? f.value : u.value);
    }, on: () => {
      v(u.value);
    }, off: () => {
      v(f.value);
    } };
  }(e, 0, { checked: n.checked, update: n.update }), s = function(i, l, a) {
    const u = an(i), f = u.disabled, h = a.checked, p = Xe(() => ({ container: "toggle-container", toggle: "toggle", toggleOn: "toggle-on", toggleOff: "toggle-off", toggleOnDisabled: "toggle-on-disabled", toggleOffDisabled: "toggle-off-disabled", handle: "toggle-handle", handleOn: "toggle-handle-on", handleOff: "toggle-handle-off", handleOnDisabled: "toggle-handle-on-disabled", handleOffDisabled: "toggle-handle-off-disabled", label: "toggle-label", ...u.classes.value }));
    return { classList: Xe(() => ({ container: p.value.container, toggle: [p.value.toggle, f.value ? h.value ? p.value.toggleOnDisabled : p.value.toggleOffDisabled : h.value ? p.value.toggleOn : p.value.toggleOff], handle: [p.value.handle, f.value ? h.value ? p.value.handleOnDisabled : p.value.handleOffDisabled : h.value ? p.value.handleOn : p.value.handleOff], label: p.value.label })) };
  }(e, 0, { checked: n.checked }), r = function(i, l, a) {
    const { disabled: u } = an(i), f = a.check, h = a.uncheck, p = a.checked;
    return { handleSpace: () => {
      u.value || (p.value ? h() : f());
    } };
  }(e, 0, { check: n.check, uncheck: n.uncheck, checked: n.checked });
  return { ...n, ...s, ...o, ...r };
} };
const Qa = ["tabindex", "aria-checked", "aria-describedby", "aria-labelledby"], Ga = ["id", "name", "value", "checked", "disabled"], ec = ["innerHTML"], tc = ["checked"];
ho.render = function(e, t, n, o, s, r) {
  return be(), et("div", Rr({ class: e.classList.container, tabindex: n.disabled ? void 0 : 0, "aria-checked": e.checked, "aria-describedby": n.describedby, "aria-labelledby": n.labelledby, role: "switch" }, n.aria, { onKeypress: t[1] || (t[1] = Sa(Nr((...i) => e.handleSpace && e.handleSpace(...i), ["prevent"]), ["space"])) }), [no(M("input", { type: "checkbox", id: n.id, name: n.name, value: n.trueValue, checked: e.checked, disabled: n.disabled }, null, 8, Ga), [[po, !1]]), M("div", { class: pt(e.classList.toggle), onClick: t[0] || (t[0] = (...i) => e.handleClick && e.handleClick(...i)) }, [M("span", { class: pt(e.classList.handle) }, null, 2), At(e.$slots, "label", { checked: e.checked, classList: e.classList }, () => [M("span", { class: pt(e.classList.label), innerHTML: e.label }, null, 10, ec)]), n.required ? (be(), et("input", { key: 0, type: "checkbox", style: { appearance: "none", height: "1px", margin: "0", padding: "0", fontSize: "0", background: "transparent", position: "absolute", width: "100%", bottom: "0", outline: "none" }, checked: e.checked, "aria-hidden": "true", tabindex: "-1", required: "" }, null, 8, tc)) : Yt("v-if", !0)], 2)], 16, Qa);
}, ho.__file = "src/Toggle.vue";
const Xr = (e, t) => {
  const n = e.__vccOpts || e;
  for (const [o, s] of t)
    n[o] = s;
  return n;
}, nc = {
  name: "ModalDialogContent",
  components: {
    ModalDialog: Fa,
    Toggle: ho
  },
  props: [
    "customParagraph",
    "noPerformance",
    "noFunctionality",
    "noAds"
  ],
  data: () => ({
    togglePerformanceCookies: !1,
    toggleFunctionalityCookies: !1,
    toggleAdsCookies: !1,
    displayModal: !1,
    displayModalParameter: !1,
    htmlBodyOverflowValue: "",
    renderCustomParagraph: !1
  }),
  created() {
    this.customParagraph != "" && (this.renderCustomParagraph = !0), this.loadData(), requestAnimationFrame(Ss);
  },
  methods: {
    async loadData() {
      Promise.all([Ye.load()]).then((e) => {
        this.displayModal = !1, e[0] !== null ? this.load(e) : this.displayModal = !0;
      });
    },
    load(e) {
      const t = {
        performanceCookies: !1,
        functionalityCookies: !1,
        adsCookies: !1
      };
      for (const [n, o] of Object.entries(e[0]))
        switch (n) {
          case "performanceCookies":
            this.togglePerformanceCookies = o, t[n] = this.togglePerformanceCookies;
            break;
          case "functionalityCookies":
            this.toggleFunctionalityCookies = o, t[n] = this.toggleFunctionalityCookies;
            break;
          case "adsCookies":
            this.toggleAdsCookies = o, t[n] = this.toggleAdsCookies;
        }
      Ye.dispatchEvent(this.checkDisabledCategories(t));
    },
    bodyScrollingOn() {
      document.body.style.overflow = this.htmlBodyOverflowValue == "" ? null : this.htmlBodyOverflowValue, [].forEach.call(
        document.querySelectorAll(".consent-container"),
        function(e) {
          e.classList.remove("overlay-modal");
        }
      );
    },
    bodyScrollingOff() {
      let e = document.body.style.overflow;
      this.htmlBodyOverflowValue = e != "" && e != "hidden" ? e : "", document.body.style.overflow = "hidden", [].forEach.call(
        document.querySelectorAll(".consent-container"),
        function(t) {
          t.classList.add("overlay-modal");
        }
      );
    },
    openModal() {
      Promise.all([Ye.load()]).then((e) => {
        e[0] !== null && this.load(e);
      }), this.displayModal = !0;
    },
    openModalParameter() {
      this.displayModal = !1, this.displayModalParameter = !0, requestAnimationFrame(Ss);
      var e = document.querySelectorAll(".ps__thumb-y");
      e.forEach((t) => t.style.height = "150px"), this.bodyScrollingOff();
    },
    closeModal() {
      this.displayModal = !1, this.displayModalParameter = !1, this.bodyScrollingOn();
    },
    // Check if preferences have disabled categories
    checkDisabledCategories(e) {
      return {
        performanceCookies: this.noPerformance ? !1 : e.performanceCookies,
        functionalityCookies: this.noFunctionality ? !1 : e.functionalityCookies,
        adsCookies: this.noAds ? !1 : e.adsCookies
      };
    },
    consentAll() {
      Ye.save(this.checkDisabledCategories({ performanceCookies: !0, functionalityCookies: !0, adsCookies: !0 })), this.togglePerformanceCookies = !0, this.toggleFunctionalityCookies = !0, this.toggleAdsCookies = !0, this.closeModal();
    },
    denyAll() {
      Ye.save({ performanceCookies: !1, functionalityCookies: !1, adsCookies: !1 }), this.togglePerformanceCookies = !1, this.toggleFunctionalityCookies = !1, this.toggleAdsCookies = !1, this.closeModal();
    },
    confirmSelection() {
      Ye.save(this.checkDisabledCategories({
        performanceCookies: !!this.togglePerformanceCookies,
        functionalityCookies: !!this.toggleFunctionalityCookies,
        adsCookies: !!this.toggleAdsCookies
      })), this.closeModal();
    }
  }
};
function Ss() {
  let e = document.querySelector(".modal-container .show-modal-step-two");
  e && e.parentNode && e.parentNode.classList.add("step-two-container");
  const t = new Lt(".consent-container .show-modal", {
    maxScrollbarLength: 150,
    minScrollbarLength: 150,
    suppressScrollX: !0
  }), n = new Lt(".consent-container .show-modal-step-two", {
    maxScrollbarLength: 150,
    minScrollbarLength: 150,
    suppressScrollX: !0
  });
  [].forEach.call(
    document.querySelectorAll(".consent-container .accordion-item"),
    function(o) {
      oc(o, (s) => {
        requestAnimationFrame(() => {
          t.update(), n.update();
        });
      });
    }
  ), [].forEach.call(
    document.querySelectorAll(".consent-container .toggle-container"),
    function(o) {
      o.addEventListener("click", function(s) {
        s.preventDefault(), s.stopPropagation();
      });
    }
  );
}
const oc = function(e, t) {
  const n = new MutationObserver((o) => {
    o.forEach((s) => {
      s.type === "attributes" && s.attributeName === "class" && t(s.target);
    });
  });
  return n.observe(e, { attributes: !0 }), n.disconnect;
}, sc = { class: "page" }, rc = { class: "show-modal" }, ic = { key: 0 }, lc = { class: "btn-modal-container" }, ac = /* @__PURE__ */ M("span", null, ">", -1), cc = { class: "learn-more-container" }, uc = ["href"], fc = ["href"], dc = { class: "show-modal-step-two" }, pc = { class: "personalized-cookies-description" }, hc = ["href"], gc = { class: "accordion-container" }, mc = /* @__PURE__ */ M("span", { class: "close" }, "+", -1), bc = /* @__PURE__ */ M("span", { class: "open" }, "-", -1), _c = { class: "toggle-container label" }, vc = { class: "list-title" }, yc = { class: "list-disc" }, wc = /* @__PURE__ */ M("span", { class: "close" }, "+", -1), xc = /* @__PURE__ */ M("span", { class: "open" }, "-", -1), kc = /* @__PURE__ */ M("span", { class: "close" }, "+", -1), Cc = /* @__PURE__ */ M("span", { class: "open" }, "-", -1), Tc = /* @__PURE__ */ M("span", { class: "close" }, "+", -1), Ec = /* @__PURE__ */ M("span", { class: "open" }, "-", -1), Ac = { class: "update-information" }, Mc = { class: "btn-modal-container" }, Oc = { class: "learn-more-container" }, Lc = ["href"], Sc = ["href"];
function Pc(e, t, n, o, s, r) {
  const i = Ft("ModalDialog"), l = Ft("AccordionItem"), a = Ft("Toggle"), u = Ft("AccordionList");
  return be(), et("div", sc, [
    M("a", {
      onClick: t[0] || (t[0] = (...f) => r.openModal && r.openModal(...f))
    }, F(e.$t("message.open_consent_preferences")), 1),
    te(i, {
      visible: e.displayModal,
      onCloseModal: r.closeModal
    }, {
      default: fe(() => [
        M("div", rc, [
          M("span", null, F(e.$t("message.accept_all_cookies_description_title")), 1),
          M("p", null, F(e.$t("message.accept_all_cookies_description_1")), 1),
          e.renderCustomParagraph ? (be(), et("p", ic, F(n.customParagraph), 1)) : Yt("", !0),
          M("div", lc, [
            M("button", {
              class: "btn-consent open-modal-parameter",
              type: "button",
              onClick: t[1] || (t[1] = (...f) => r.openModalParameter && r.openModalParameter(...f))
            }, [
              me(F(e.$t("message.cookie_settings_button")) + " ", 1),
              ac
            ]),
            M("button", {
              class: "btn-consent",
              type: "button",
              onClick: t[2] || (t[2] = (...f) => r.denyAll && r.denyAll(...f))
            }, F(e.$t("message.deny_all_cookies_button")), 1),
            M("button", {
              class: "btn-consent",
              type: "button",
              onClick: t[3] || (t[3] = (...f) => r.consentAll && r.consentAll(...f))
            }, F(e.$t("message.allow_all_cookies_button")), 1)
          ]),
          M("div", cc, [
            me(F(e.$t("message.accept_all_cookies_description_2_1")) + " ", 1),
            M("a", {
              href: e.$t("message.policy_url")
            }, F(e.$t("message.policy_url_text")), 9, uc),
            me(" " + F(e.$t("message.accept_all_cookies_description_2_2")) + " ", 1),
            M("a", {
              href: e.$t("message.term_url")
            }, F(e.$t("message.term_url_text")), 9, fc),
            me(". ")
          ])
        ])
      ]),
      _: 1
    }, 8, ["visible", "onCloseModal"]),
    te(i, {
      visible: e.displayModalParameter,
      onCloseModal: r.closeModal
    }, {
      default: fe(() => [
        M("div", dc, [
          M("span", null, F(e.$t("message.privacy_preference_center_description_title")), 1),
          M("div", pc, [
            M("p", null, F(e.$t("message.privacy_preference_center_description_1")), 1),
            M("p", null, F(e.$t("message.privacy_preference_center_description_2")), 1),
            M("p", null, [
              me(F(e.$t("message.privacy_preference_center_description_3_1")) + " ", 1),
              M("a", {
                href: e.$t("message.privacy_preference_center_description_3_url"),
                target: "_blank"
              }, F(e.$t("message.privacy_preference_center_description_3_text")), 9, hc),
              me(F(e.$t("message.privacy_preference_center_description_3_2")), 1)
            ]),
            M("p", null, F(e.$t("message.privacy_preference_center_description_4")), 1)
          ]),
          M("div", gc, [
            te(u, { "open-multiple-items": "" }, {
              default: fe(() => [
                te(l, null, {
                  summary: fe(() => [
                    me(F(e.$t("message.strictly_necessary_cookies")), 1)
                  ]),
                  icon: fe(() => [
                    mc,
                    bc,
                    M("div", _c, F(e.$t("message.always_on")), 1)
                  ]),
                  default: fe(() => [
                    M("p", null, F(e.$t("message.strictly_necessary_cookies_description_1")), 1),
                    M("p", vc, F(e.$t("message.strictly_necessary_cookies_description_2")), 1),
                    M("ul", yc, [
                      M("li", null, F(e.$t("message.strictly_necessary_cookies_description_li_1")), 1),
                      M("li", null, F(e.$t("message.strictly_necessary_cookies_description_li_2")), 1),
                      M("li", null, F(e.$t("message.strictly_necessary_cookies_description_li_3")), 1),
                      M("li", null, F(e.$t("message.strictly_necessary_cookies_description_li_4")), 1),
                      M("li", null, F(e.$t("message.strictly_necessary_cookies_description_li_5")), 1)
                    ])
                  ]),
                  _: 1
                }),
                n.noPerformance ? Yt("", !0) : (be(), gt(l, { key: 0 }, {
                  summary: fe(() => [
                    me(F(e.$t("message.performance_cookies")), 1)
                  ]),
                  icon: fe(() => [
                    wc,
                    xc,
                    te(a, {
                      modelValue: e.togglePerformanceCookies,
                      "onUpdate:modelValue": t[4] || (t[4] = (f) => e.togglePerformanceCookies = f)
                    }, null, 8, ["modelValue"])
                  ]),
                  default: fe(() => [
                    M("p", null, F(e.$t("message.performance_cookies_description_1")), 1)
                  ]),
                  _: 1
                })),
                n.noFunctionality ? Yt("", !0) : (be(), gt(l, { key: 1 }, {
                  summary: fe(() => [
                    me(F(e.$t("message.functionality_cookies")), 1)
                  ]),
                  icon: fe(() => [
                    kc,
                    Cc,
                    te(a, {
                      modelValue: e.toggleFunctionalityCookies,
                      "onUpdate:modelValue": t[5] || (t[5] = (f) => e.toggleFunctionalityCookies = f)
                    }, null, 8, ["modelValue"])
                  ]),
                  default: fe(() => [
                    M("p", null, F(e.$t("message.functionality_cookies_description_1")), 1)
                  ]),
                  _: 1
                })),
                n.noAds ? Yt("", !0) : (be(), gt(l, { key: 2 }, {
                  summary: fe(() => [
                    me(F(e.$t("message.cookies_for_targeted_advertising")), 1)
                  ]),
                  icon: fe(() => [
                    Tc,
                    Ec,
                    te(a, {
                      modelValue: e.toggleAdsCookies,
                      "onUpdate:modelValue": t[6] || (t[6] = (f) => e.toggleAdsCookies = f)
                    }, null, 8, ["modelValue"])
                  ]),
                  default: fe(() => [
                    M("p", null, F(e.$t("message.cookies_for_targeted_advertising_description_1")), 1)
                  ]),
                  _: 1
                }))
              ]),
              _: 1
            }),
            M("p", Ac, F(e.$t("message.update_information")), 1),
            M("div", Mc, [
              M("button", {
                onClick: t[7] || (t[7] = (...f) => r.confirmSelection && r.confirmSelection(...f)),
                type: "button",
                class: "btn-consent confirm-selection"
              }, F(e.$t("message.confirm_selection")), 1),
              M("button", {
                class: "btn-consent",
                type: "button",
                onClick: t[8] || (t[8] = (...f) => r.denyAll && r.denyAll(...f))
              }, F(e.$t("message.deny_all_cookies_button")), 1),
              M("button", {
                class: "btn-consent",
                type: "button",
                onClick: t[9] || (t[9] = (...f) => r.consentAll && r.consentAll(...f))
              }, F(e.$t("message.allow_all_cookies_button")), 1)
            ]),
            M("div", Oc, [
              me(F(e.$t("message.accept_all_cookies_description_2_1")) + " ", 1),
              M("a", {
                href: e.$t("message.policy_url")
              }, F(e.$t("message.policy_url_text")), 9, Lc),
              me(" " + F(e.$t("message.accept_all_cookies_description_2_2")) + " ", 1),
              M("a", {
                href: e.$t("message.term_url")
              }, F(e.$t("message.term_url_text")), 9, Sc),
              me(". ")
            ])
          ])
        ])
      ]),
      _: 1
    }, 8, ["visible", "onCloseModal"])
  ]);
}
const Ic = /* @__PURE__ */ Xr(nc, [["render", Pc]]), Rc = {
  name: "App",
  components: {
    ModalDialogContent: Ic
  }
};
function Hc(e, t, n, o, s, r) {
  const i = Ft("ModalDialogContent");
  return be(), gt(i);
}
const $c = /* @__PURE__ */ Xr(Rc, [["render", Hc]]);
/*!
  * vue-i18n-lite v1.0.2
  * (c) 2021 Erik Pham
  * @license MIT
  */
const Dc = ["__proto__", "prototype", "constructor"];
function Nc(e) {
  const t = typeof e;
  return e !== null && (t === "object" || t === "function");
}
function Fc(e) {
  return !(Array.isArray(e) ? e.length : Object.keys(e).length);
}
function Wc(e) {
  return !e.some((t) => Dc.indexOf(t) !== -1);
}
function Yc(e) {
  const t = e.split("."), n = [];
  for (let o = 0; o < t.length; o++) {
    let s = t[o];
    for (; s[s.length - 1] === "\\" && t[o + 1] !== void 0; )
      s = s.slice(0, -1) + ".", s += t[++o];
    n.push(s);
  }
  return Wc(n) ? n : [];
}
function Ps(e, t) {
  if (!Nc(e))
    return "";
  const n = Yc(t);
  if (n.length === 0)
    return "";
  let o = Object.assign({}, e);
  for (let s = 0; s < n.length; s++) {
    if (typeof o[n[s]] == "string")
      return o[n[s]];
    if (o = o[n[s]], o == null) {
      if (s !== n.length - 1)
        return "";
      break;
    }
  }
  return "";
}
function Bc(e, t) {
  if (Array.isArray(t)) {
    const n = {}, o = [...e.matchAll(/{(.+?)}/g)];
    return o && o.forEach((s, r) => {
      t[r] && (n[s[1]] = t[r]);
    }), n;
  }
  return t;
}
function Xc(e, t) {
  for (const n in t)
    e = e.replace(`{${n}}`, String(t[n]));
  return e;
}
function jr(e, t) {
  return Object.keys(t).forEach((n) => {
    t[n] instanceof Object && n in e && (t[n] = { ...t[n], ...jr(e[n], t[n]) });
  }), { ...e || {}, ...t };
}
const jc = typeof Symbol == "function" && typeof Symbol.toStringTag == "symbol", zc = (e) => jc ? Symbol(e) : "_vt_" + e, qc = /* @__PURE__ */ zc("i18n");
function Kc(e) {
  const t = Object.assign({ locale: "en", fallbackLocale: "en", messages: {} }, e), n = Be(t.locale), o = Ln({});
  return Object.entries(t.messages).forEach(([s, r]) => {
    o[s] = r;
  }), {
    t(s, r) {
      if (!s)
        return "";
      const i = typeof r == "string" && r ? r : n.value;
      let l = Ps(o[i], s) || Ps(o[t.fallbackLocale], s);
      if (r && typeof r != "string") {
        const a = Bc(l, r);
        Fc(a) || (l = Xc(l, a));
      }
      return l || s;
    },
    current: _n(n),
    options: _n(e || {}),
    install(s) {
      const r = this;
      s.config.globalProperties.$t = r.t, s.provide(qc, r);
    },
    changeLocale(s) {
      n.value = s;
    },
    setLocaleMessage(s, r) {
      o[s] = jr(B(o[s] || {}), r);
    },
    getLocaleMessage(s) {
      return o[s] || {};
    }
  };
}
let Uc = ["en", "en-US", "en-CA", "en-EN"].includes(document.getElementsByTagName("html")[0].getAttribute("lang")) ? "en" : "fr";
const Vc = Kc({
  legacy: !1,
  locale: Uc,
  messages: {
    en: {
      message: {
        open_consent_preferences: "Cookie Settings",
        accept_all_cookies_description_title: "UdeM understands the importance of privacy",
        accept_all_cookies_description_1: "Cookies allow us to enhance and personalize your browsing experience. Some cookies are required to ensure the websites functionality and security, while others remember your preferences. By accepting all, you consent to our use of cookies to better serve you.",
        accept_all_cookies_description_2_1: "See our",
        policy_url: "https://vie-privee.umontreal.ca/confidentialite",
        policy_url_text: "privacy policy",
        accept_all_cookies_description_2_2: "and ",
        term_url: "https://vie-privee.umontreal.ca/conditions-dutilisation",
        term_url_text: "terms of use",
        cookie_settings_button: "Manage cookies",
        allow_all_cookies_button: "Accept all",
        deny_all_cookies_button: "Reject all",
        privacy_preference_center_description_title: "Manage cookies",
        privacy_preference_center_description_1: "Cookies are small text files that are downloaded when you visit certain pages of a website and stored in the memory of the device you are using. They record certain information (browser type, language, country, IP address, identifier, etc.) for retrieval by the server on subsequent visits. They are used to update and optimize our platforms according to your use and needs.",
        privacy_preference_center_description_2: "UdeM collects data on its platforms to analyze their use and improve the visitor experience.",
        privacy_preference_center_description_3_1: "UdeM also uses",
        privacy_preference_center_description_3_url: "https://vie-privee.umontreal.ca/ga-en",
        privacy_preference_center_description_3_text: " Google Analytics",
        privacy_preference_center_description_3_2: " to analyze Web traffic and collect browsing data for statistical purposes and to improve its platforms.",
        privacy_preference_center_description_4: "Because we respect your right to privacy, we give you the option of declining certain types of cookies. Click on a category for more details and to change the default settings. However, disabling some types of cookies may affect your browsing experience and the services we are able to offer you.",
        strictly_necessary_cookies: "Required cookies",
        strictly_necessary_cookies_description_1: "These cookies are essential for the functioning and security of our website and online services. They cannot be disabled. Among other things, they enable us to secure your connection by collecting identifying information, to personalize your interface (e.g. language selection) and to store your preferences.",
        strictly_necessary_cookies_description_2: "The information collected includes:",
        strictly_necessary_cookies_description_li_1: "browser language",
        strictly_necessary_cookies_description_li_2: "browser type and version",
        strictly_necessary_cookies_description_li_3: "operating system type and version",
        strictly_necessary_cookies_description_li_4: "device type (phone, tablet or computer) and model",
        strictly_necessary_cookies_description_li_5: "screen resolution of your device",
        performance_cookies: "Analytics cookies",
        performance_cookies_description_1: "These cookies are used to analyze traffic on our sites (origin of visitors, frequency of visits, frequency of views per page, etc.) in order to improve the sites operation and offer visitors a better user experience. All the information collected by these cookies is aggregated and therefore anonymous.",
        functionality_cookies: "Functionality cookies",
        functionality_cookies_description_1: "These cookies enable us to improve and customize the functionality of our sites. For example, they make it possible to use video and instant messaging services, and to share content from our sites on social media. Disabling these cookies may affect your browsing experience and the services we are able to offer you.",
        cookies_for_targeted_advertising: "Advertising cookies",
        cookies_for_targeted_advertising_description_1: "These cookies may be enabled on our website to build profiles about your interests. They help us to serve you personalized advertisements and content on other sites. targeted to your interests will be offered to you when you browse other websites.",
        update_information: "You can change your preferences at any time by adjusting your browser settings to accept or block cookies.",
        confirm_selection: "Save my preferences",
        always_on: "Always enabled"
      }
    },
    fr: {
      message: {
        open_consent_preferences: "Paramtres des tmoins",
        accept_all_cookies_description_title: "LUdeM reconnat limportance de respecter la vie prive",
        accept_all_cookies_description_1: "Lutilisation de tmoins nous permet damliorer et de personnaliser votre exprience Web. Certains tmoins sont obligatoires pour assurer le fonctionnement et la scurit du site Web, alors que dautres enregistrent vos prfrences. En acceptant tout, vous consentez  notre utilisation de tmoins pour mieux rpondre  vos besoins.",
        accept_all_cookies_description_2_1: "Voir notre",
        policy_url: "https://vie-privee.umontreal.ca/confidentialite",
        policy_url_text: "politique de confidentialit",
        accept_all_cookies_description_2_2: "et nos ",
        term_url: "https://vie-privee.umontreal.ca/conditions-dutilisation",
        term_url_text: "conditions dutilisation",
        cookie_settings_button: "Personnaliser les tmoins",
        allow_all_cookies_button: "Tout accepter",
        deny_all_cookies_button: "Tout refuser",
        privacy_preference_center_description_title: "Personnaliser les tmoins",
        privacy_preference_center_description_1: "Les tmoins (aussi appels cookies) sont de petits fichiers textes qui sont tlchargs lorsque vous consultez certaines pages dun site et qui sont enregistrs dans la mmoire de lappareil que vous utilisez. Ils permettent denregistrer certaines informations (type de navigateur, langue, pays, adresse IP, identifiant, etc.) afin dtre rcupres par le serveur lors de visites subsquentes. Ils sont utiliss pour mettre  jour et optimiser nos plateformes en fonction de lutilisation que vous en faites et de vos besoins.",
        privacy_preference_center_description_2: "LUdeM collecte des donnes sur les plateformes, afin danalyser leur utilisation et damliorer lexprience des visiteurs.",
        privacy_preference_center_description_3_1: "LUdeM utilise galement les services de",
        privacy_preference_center_description_3_url: "https://vie-privee.umontreal.ca/ga",
        privacy_preference_center_description_3_text: " Google Analytics",
        privacy_preference_center_description_3_2: ", afin d'analyser le trafic Web et de recueillir des donnes de navigation  des fins statistiques et damlioration des Plateformes.",
        privacy_preference_center_description_4: "Parce que nous respectons votre droit  la vie prive, nous vous donnons la possibilit de ne pas autoriser certains types de tmoins. Cliquez sur les diffrentes catgories pour obtenir plus de dtails sur chacune dentre elles et modifier les paramtres par dfaut. Toutefois, si vous dsactivez certains types de tmoins, votre exprience de navigation et les services que nous sommes en mesure de vous offrir peuvent tre impacts.",
        strictly_necessary_cookies: "Tmoins ncessaires",
        strictly_necessary_cookies_description_1: "Ces tmoins sont essentiels au bon fonctionnement et  la scurit de nos sites Web et services en ligne. Ils ne peuvent pas tre dsactivs. Ils nous permettent notamment de scuriser votre connexion en recueillant vos informations didentification, personnaliser votre interface (ex. : choix de langue) et conserver vos prfrences.",
        strictly_necessary_cookies_description_2: "Les renseignements suivants sont notamment recueillis:",
        strictly_necessary_cookies_description_li_1: "le type et la version du navigateur;",
        strictly_necessary_cookies_description_li_2: "le type et la version du systme dexploitation;",
        strictly_necessary_cookies_description_li_3: "le type et le modle dappareil (tlphone, tablette ou ordinateur);",
        strictly_necessary_cookies_description_li_4: "la rsolution de lcran de lappareil que vous utilisez;",
        strictly_necessary_cookies_description_li_5: "la langue utilise par le navigateur.",
        performance_cookies: "Tmoins de performance",
        performance_cookies_description_1: "Ces tmoins sont utiliss pour analyser la navigation sur nos sites (provenance des visiteurs, frquence des visites, pages plus ou moins visites, etc.) dans le but den amliorer le fonctionnement et doffrir une meilleure exprience utilisateurs aux visiteurs. Toutes les informations collectes par ces tmoins sont agrges et donc anonymises.",
        functionality_cookies: "Tmoins de fonctionnalit",
        functionality_cookies_description_1: "Ces tmoins permettent damliorer les fonctionnalits et la personnalisation de nos sites. Par exemple, ils rendent possible lutilisation de vidos et de services de messagerie instantane ou encore le partage de contenus de nos sites sur des plateformes de mdias sociaux. Si vous dsactivez ces tmoins, votre exprience de navigation et les services que nous sommes en mesure de vous offrir peuvent tre impacts.",
        cookies_for_targeted_advertising: "Tmoins publicitaires",
        cookies_for_targeted_advertising_description_1: "Ces tmoins peuvent tre activs sur nos sites web pour tablir des profils sur vos intrts. Ils nous aident  vous proposer des publicits et des contenus personnaliss. Si vous dsactivez ces tmoins, des publicits et des contenus moins cibles sur vos intrts vous seront proposs.",
        update_information: "Vous pouvez modifier en tout temps vos prfrences en slectionnant les paramtres appropris dans votre navigateur pour accepter ou refuser les tmoins.",
        confirm_selection: "Enregistrer mes prfrences",
        always_on: "Toujours activs"
      }
    }
  }
}), Jc = Vc, zr = "PROVIDE_INJECT_KEY_ACCORDION_LIST", Zc = /* @__PURE__ */ Lo({
  __name: "AccordionList",
  props: {
    openMultipleItems: { type: Boolean },
    state: null,
    setClosePropertyTime: null
  },
  emits: ["update:state"],
  setup(e, { emit: t }) {
    const n = e, o = Be({}), s = Xe({
      set(p) {
        !!n.state ? t("update:state", p) : o.value = p;
      },
      get() {
        return n.state ? n.state : o.value;
      }
    }), r = Xe(() => Object.values(s.value).some((p) => p));
    let i = 0, l = null;
    const a = Be();
    function u() {
      var p;
      l == null || l.disconnect(), l = new ResizeObserver((v) => {
        v.forEach(({ target: y, contentRect: R }) => {
          var T, E, H, O;
          y.classList.contains("accordion-item__content") && ((E = (T = y.parentElement) == null ? void 0 : T.style) == null || E.setProperty("--content-height", `${R.height}px`)), y.tagName.toLowerCase() === "summary" && ((O = (H = y.parentElement) == null ? void 0 : H.style) == null || O.setProperty("--summary-height", `${R.height}px`));
        });
      }), (((p = a.value) == null ? void 0 : p.querySelectorAll(".accordion-item__content, summary")) || []).forEach((v) => l == null ? void 0 : l.observe(v));
    }
    function f(p) {
      !!l && u();
      const v = !r.value || !!n.openMultipleItems, y = p.id || (i++).toString(), T = !!p.defaultOpened && v || !!p.isOnServerOpened || s.value[y];
      return s.value[y] = T, { id: y, isItemOpened: T };
    }
    function h(p) {
      const w = { ...s.value }, v = !w[p];
      n.openMultipleItems || Object.keys(w).forEach((y) => w[y] = !1), w[p] = v, s.value = w;
    }
    return Hn(u), So(() => {
      l && (l.disconnect(), l = null);
    }), Tr(zr, {
      init: f,
      trigger: h,
      setClosePropertyTime: n.setClosePropertyTime || 100,
      accordionListState: s
    }), (p, w) => (be(), et("div", {
      ref_key: "rootElementRef",
      ref: a,
      class: "accordion-list"
    }, [
      At(p.$slots, "default")
    ], 512));
  }
}), Qc = ["open", "data-id", "data-is-on-server-opened"], Gc = ["onClick"], eu = { class: "accordion-item__summary-title" }, tu = {
  key: 0,
  class: "accordion-item__summary-icon"
}, nu = {
  key: 1,
  class: "accordion-item__summary-icon accordion-item__summary-icon--default"
}, ou = { class: "accordion-item__content" }, su = /* @__PURE__ */ Lo({
  __name: "AccordionItem",
  props: {
    id: null,
    defaultOpened: { type: Boolean },
    disabled: { type: Boolean }
  },
  setup(e) {
    const t = e, { trigger: n, init: o, accordionListState: s, setClosePropertyTime: r } = jt(zr) || {}, i = Xe(() => (s == null ? void 0 : s.value[a.value]) || !1), l = Be(), a = Be(""), u = Be(!1), f = Be(i.value), h = Be(!1), p = Be("");
    yr(async () => {
      if (!o) {
        console.error("no initItem function provided, please use AccordionItem only inside AccordionList");
        return;
      }
      const { id: T, isItemOpened: E } = o({ ...t });
      h.value = E, p.value = T;
    }), Hn(() => {
      var T, E, H;
      if (!o) {
        console.error("no initItem function provided, please use AccordionItem only inside AccordionList");
        return;
      }
      (T = l.value) != null && T.dataset.id && (a.value = l.value.dataset.id);
      const O = ((H = (E = l.value) == null ? void 0 : E.dataset) == null ? void 0 : H.isOnServerOpened) == "true", { id: V } = o({ ...t, isOnServerOpened: O });
      a.value = V;
    });
    function w() {
      !n || t.disabled || n(a.value);
    }
    const v = Xe(() => ({
      "accordion-item--open": i.value || h.value,
      "accordion-item--disabled": t.disabled
    }));
    function y() {
      u.value = !0;
    }
    function R() {
      u.value = !1, f.value = i.value;
    }
    return hn(i, (T) => {
      if (T) {
        f.value = !0;
        return;
      }
      setTimeout(() => {
        u.value || (f.value = !1);
      }, r);
    }), (T, E) => (be(), et("details", {
      ref_key: "detailsRef",
      ref: l,
      class: pt(["accordion-item", rr(v)]),
      open: f.value || h.value,
      "data-id": p.value,
      "data-is-on-server-opened": h.value,
      onTransitionrun: y,
      onTransitionend: R
    }, [
      M("summary", {
        class: "accordion-item__summary",
        onClick: Nr(w, ["prevent"])
      }, [
        M("span", eu, [
          At(T.$slots, "summary")
        ]),
        T.$slots.icon ? (be(), et("span", tu, [
          At(T.$slots, "icon")
        ])) : (be(), et("span", nu))
      ], 8, Gc),
      M("div", ou, [
        At(T.$slots, "default")
      ])
    ], 42, Qc));
  }
}), ru = {
  install: function(e) {
    e.component("AccordionList", Zc), e.component("AccordionItem", su);
  }
}, Is = () => {
  let e = ["en", "en-US", "en-CA", "en-EN"].includes(document.getElementsByTagName("html")[0].getAttribute("lang")), t = "", n = "", o = "", s = "", r = document.getElementById("udem_cookie_consent_toggle");
  r ? (e = e ? "data-custom-paragraph-en" : "data-custom-paragraph-fr", t = r.getAttribute(e) || "", n = r.hasAttribute("data-no-performance"), o = r.hasAttribute("data-no-functionality"), s = r.hasAttribute("data-no-ads")) : (r = document.createElement("div"), r.id = "udem_cookie_consent_toggle", document.body.appendChild(r));
  const i = Ra($c, {
    customParagraph: t,
    noPerformance: n,
    noFunctionality: o,
    noAds: s
  });
  i.use(Jc), i.use(ru), i.mount("#udem_cookie_consent_toggle");
};
document.readyState && document.readyState !== "loading" ? requestAnimationFrame(Is) : window.addEventListener("DOMContentLoaded", Is);
const No = document.createElement("style");
No.setAttribute("id", "udem_cookie_consent_style");
No.appendChild(document.createTextNode(Ur));
document.head.appendChild(No);
const Rs = [];
globalThis.on_udem_cookie_update_consent = function(e) {
  typeof e == "function" && Ye.addEventListener(Ye.EVENT_TYPE_CONSENT, function(n) {
    n.detail.update === !0 && e(n.detail);
  });
  const t = ["performanceCookies", "functionalityCookies", "adsCookies"];
  if (Rs.indexOf(t[0]) === -1) {
    const n = {};
    Ye.load().then((o) => {
      if (o !== null) {
        for (const [s, r] of Object.entries(o))
          Rs.push(t[s]), n[s] = r;
        e(n);
      }
    });
  }
};
globalThis.udem_open_cookie_consent_dialog = function(e) {
  e && typeof e.preventDefault == "function" && e.preventDefault();
  let t = document.getElementById("udem_cookie_consent_toggle"), n = t == null ? void 0 : t.querySelector("a");
  n == null || n.click();
  let o = document.querySelector(".open-modal-parameter");
  o == null || o.click();
};
globalThis.udem_open_cookie_consent_intro = function(e) {
  e && typeof e.preventDefault == "function" && e.preventDefault();
  let t = document.getElementById("udem_cookie_consent_toggle"), n = t == null ? void 0 : t.querySelector("a");
  n == null || n.click();
};
})()